{
    "auth": "none",
    "calls": {
        "ACq": {
            "0": "A",
            "1": "C",
            "2": "p",
            "body": "{\n\t\"requests\": [{\n\t\t\t\"action\": \"addObject\",\n\t\t\t\"body\": {\n\t\t\t\t\"name\": \"Betty Jane Mccamey\",\n\t\t\t\t\"company\": \"Vita Foods Inc.\",\n\t\t\t\t\"email\": \"betty@mccamey.com\"\n\t\t\t}\n\t\t},\n\t\t{\n\t\t\t\"action\": \"addObject\",\n\t\t\t\"body\": {\n\t\t\t\t\"name\": \"Gayla Geimer\",\n\t\t\t\t\"company\": \"Ortman Mccain Co\",\n\t\t\t\t\"email\": \"gayla@geimer.com\"\n\t\t\t}\n\t\t}\n\t]\n}",
            "doc_link": "https://www.algolia.com/doc/rest-api/search/#batch-write-operations",
            "initialized": true,
            "method": "post",
            "name": "üìùBatchWriteObjects",
            "publish_as": "action",
            "rank": 2,
            "ret_value": "api.1579418404674x846189550255734800.plugin_api.ACq",
            "types": "{\"plugin_api.ACq\":{\"caption\":\"üìùAddObject\",\"fields\":{\"_p_objectIDs\":{\"ret_value\":\"list.text\",\"caption\":\"objectIDs\",\"path\":[\"objectIDs\"]},\"_p_taskID\":{\"ret_value\":\"number\",\"caption\":\"taskID\",\"path\":[\"taskID\"]}}}}",
            "url": "https://[üî†AppId]-dsn.algolia.net/1/indexes/[üî†IndexName]/batch",
            "url_params": {
                "ABG": {
                    "doc": "Identifies which application you are accessing.",
                    "key": "üî†AppId",
                    "private": true,
                    "value": ""
                },
                "ABv": {
                    "doc": "Identifies which index you are accessing.",
                    "key": "üî†IndexName",
                    "private": true,
                    "value": ""
                }
            }
        },
        "ACs": {
            "0": "A",
            "1": "C",
            "2": "r",
            "body": "{\n    \"params\": \"query=<üî†Query>&similarQuery=<üî†SimilarQuery>&attributesToRetrieve=<üî†AttributesToRetrieve>&hitsPerPage=2&getRankingInfo=1\"\n}",
            "body_params": {
                "ACh": {
                    "doc": "The text to search in the index.",
                    "key": "üî†Query",
                    "private": true,
                    "value": "gang"
                },
                "ACk": {
                    "key": "üî†SimilarQuery",
                    "private": true,
                    "value": ""
                },
                "ACo": {
                    "doc": "",
                    "key": "üî†AttributesToRetrieve",
                    "private": true,
                    "value": ""
                }
            },
            "doc_link": "https://www.algolia.com/doc/rest-api/search/#get-logs",
            "initialized": true,
            "method": "get",
            "name": "üìñLogs",
            "params": {
                "ACu": {
                    "doc": "First entry to retrieve (zero-based). Log entries are sorted by decreasing date, therefore 0 designates the most recent log entry.",
                    "key": "offset",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "ACv": {
                    "doc": "Maximum number of entries to retrieve. Maximum allowed value: 1000.",
                    "key": "length",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "ACz": {
                    "doc": "Index for which log entries should be retrieved. When omitted, log entries are retrieved across all indices.",
                    "key": "indexName",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "ADA": {
                    "doc": "Type of log entries to retrieve. When omitted, all log entries are retrieved.\n\nThis parameter is useful for debugging, especially when it is difficult to locate errors among many API calls:\n\nall: retrieve all logs\nquery: retrieve only search queries\nbuild: retrieve only build operations\nerror: retrieve only errors\nYou can retrieve the logs of your last 1,000 API calls. It is designed for real-time, immediate debugging.",
                    "key": "type",
                    "optional": true,
                    "private": true,
                    "value": ""
                }
            },
            "publish_as": "data",
            "rank": 4,
            "ret_value": "api.1579418404674x846189550255734800.plugin_api.ACs",
            "types": "{\"plugin_api.ACs\":{\"caption\":\"üìñAlgoliaLog\",\"fields\":{\"_p_logs\":{\"ret_value\":\"list.api.1579418404674x846189550255734800.plugin_api.ACs.logs\",\"caption\":\"logs\",\"path\":[\"logs\"]}}},\"plugin_api.ACs.logs\":{\"caption\":\"üìñAlgoliaLogs log\",\"fields\":{\"_p_timestamp\":{\"ret_value\":\"text\",\"caption\":\"timestamp\",\"path\":[\"timestamp\"]},\"_p_method\":{\"ret_value\":\"text\",\"caption\":\"method\",\"path\":[\"method\"]},\"_p_answer_code\":{\"ret_value\":\"text\",\"caption\":\"answer_code\",\"path\":[\"answer_code\"]},\"_p_query_body\":{\"ret_value\":\"text\",\"caption\":\"query_body\",\"path\":[\"query_body\"]},\"_p_answer\":{\"ret_value\":\"text\",\"caption\":\"answer\",\"path\":[\"answer\"]},\"_p_url\":{\"ret_value\":\"text\",\"caption\":\"url\",\"path\":[\"url\"]},\"_p_ip\":{\"ret_value\":\"text\",\"caption\":\"ip\",\"path\":[\"ip\"]},\"_p_query_headers\":{\"ret_value\":\"text\",\"caption\":\"query_headers\",\"path\":[\"query_headers\"]},\"_p_sha1\":{\"ret_value\":\"text\",\"caption\":\"sha1\",\"path\":[\"sha1\"]},\"_p_nb_api_calls\":{\"ret_value\":\"text\",\"caption\":\"nb_api_calls\",\"path\":[\"nb_api_calls\"]},\"_p_processing_time_ms\":{\"ret_value\":\"text\",\"caption\":\"processing_time_ms\",\"path\":[\"processing_time_ms\"]},\"_p_index\":{\"ret_value\":\"text\",\"caption\":\"index\",\"path\":[\"index\"]},\"_p_query_params\":{\"ret_value\":\"text\",\"caption\":\"query_params\",\"path\":[\"query_params\"]},\"_p_query_nb_hits\":{\"ret_value\":\"text\",\"caption\":\"query_nb_hits\",\"path\":[\"query_nb_hits\"]}}}}",
            "url": "https://[üî†AppId]-dsn.algolia.net/1/logs",
            "url_params": {
                "ABG": {
                    "doc": "Identifies which application you are accessing.",
                    "key": "üî†AppId",
                    "private": true,
                    "value": ""
                }
            }
        },
        "AFk": {
            "0": "A",
            "1": "F",
            "2": "j",
            "body": "",
            "doc_link": "https://www.algolia.com/doc/rest-api/search/#search-index-get",
            "initialized": true,
            "method": "get",
            "name": "üîçSearchIndex",
            "params": {
                "ADN": {
                    "doc": "The text to search in the index.\n\nUsage notes:#\nIf the text is empty or absent, the search will match every object in your index.\n\nIn our documentation, we use the terms ‚Äúquery‚Äù, ‚Äúquery terms‚Äù, or ‚Äúsearch text‚Äù to mean the same thing, namely: the text used to search the index.\n\nThere‚Äôs a hard limit of 512 characters per query. If a search query is longer, the API will return an error.",
                    "key": "query",
                    "optional": false,
                    "private": true,
                    "value": "test"
                },
                "ADO": {
                    "doc": "Overrides the query parameter and performs a more generic search that can be used to find ‚Äúsimilar‚Äù results.\n\nUsage notes:#\nsimilarQuery should be constructed from the tags and keywords of the object you are trying to find related results to.\n\nsimilarQuery is not automatically generated. You need to select which keywords you think would be useful. For example, a similarQuery for a movie could use the genre, principle actors, and tags attributes. After extracting information from those categories, you might end up with a similarQuery that looks like: ‚ÄúRomance Comedy Gordon-Levitt NY‚Äù. Check out the examples section for a more detailed walk-through.\n\nUse of this parameter changes the search settings in four ways:\n\nSets queryType to prefixNone (no prefix match).\nmatched prefixes are not counted as word matches.\nSets removeStopWords to true.\nstop words like ‚Äòthe‚Äô, ‚Äòa‚Äô, ‚Äòan‚Äô are removed.\nTreats all remaining words (all non-stopwords) as optional.\nobjects that match any word in similarQuery will be returned.\nnote, your similarQuery will likely invoke the caveat behavior of the optionalWords parameter!\nSets words to be the first ranking criteria\nthe number of exactly matching words is the first ranking criteria.\nNote, because the optionalWords parameter (which is leveraged by similarQuery) can yield a high volume of results, you should add filters and optional filters to your similar searches.",
                    "key": "similarQuery",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "ADP": {
                    "doc": "Gives control over which attributes to retrieve and which not to retrieve.\n\nYou don‚Äôt always need to retrieve a full response that includes every attribute in your index. Sometimes you may only want to receive the most relevant attributes, or exclude attributes used only for internal purposes.\n\nThis setting helps reduce your response size and improve performance.\n\nUsage notes:#\nSpecial Characters:\nUse * to retrieve all values.\n\nAppend a dash (-) to an attribute that you do NOT wish to retrieve. Example below. Without prefixing an attribute with -, the attribute will be retrieved.\n\nNote that negative attributes (-) only work when using *. For example, [‚Äú*‚Äù, ‚Äú-title‚Äù] retrieves every attribute except ‚Äútitle‚Äù.\n\nobjectID is always retrieved, even when not specified.\n\nAlso note that using negative attributes doesn‚Äôt make them unsearchable. If your users make queries that match an attribute not to retrieve, they will still get the same results, but the attribute won‚Äôt be part of the response.\n\nAttributes listed in unretrievableAttributes will not be retrieved even if requested, unless the request is authenticated with the admin API key.",
                    "key": "attributesToRetrieve",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEZ": {
                    "doc": "Restricts a given query to look in only a subset of your searchable attributes.\n\nThis setting overrides searchableAttributes for specific searches.\n\nUsage notes:#\nThis setting is a query-level setting, affecting only the search that specifies it.\nsearchableAttributes must not be empty nor null for restrictSearchableAttributes to be applied.",
                    "key": "restrictSearchableAttributes",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEa": {
                    "doc": "Filter the query with numeric, facet and/or tag filters.\n\nThis parameter uses SQL-like syntax, where you can use boolean operators and parentheses to combine individual filters.\n\nNote that each attribute you use in filters must be defined as a facet. The _tags attribute is automatically defined as a facet.\n\nNumeric Comparisons#\n\nFormat: ${attributeName} ${operator} ${value}\nExample: price > 12.99\n\nThe ${value} must be numeric. Supported operators are <, <=, =, !=, >= and >, with the same semantics as in virtually all programming languages.\n\nNumeric Range#\n\nFormat: ${attributeName}:${lowerBound} TO ${upperBound}\nExample: price:5.99 TO 100\n\n${lowerBound} and ${upperBound} must be numeric. Both are inclusive.\n\nFacet filters#\n\nFormat: ${facetName}:${facetValue}\nExample: category:Book\n\nFacet matching is not case sensitive.\n\nWhen ${facetName} contains string values, it needs to be declared inside attributesForFaceting\n\nTag filters#\n\nFormat: _tags:${value} (or, alternatively, just ${value})\nExample: _tags:published\n\nTag matching is case sensitive.\n\nIf no attribute name is specified, the filter applies to _tags. For example: public OR user_42 will translate into _tags:public OR _tags:user_42.\n\nBoolean filters\n\nFormat: facetName:${boolean_value}\nExample: isEnabled:true\n\nWhen ${facetName} needs to be declared inside attributesForFaceting\n\nBoolean operators#\n\nExample:\n\nprice < 10 AND (category:Book OR NOT category:Ebook)\nIndividual filters can be combined via boolean operators. The following operators are supported:\n\nOR: must match any of the combined conditions (disjunction)\nAND: must match all of the combined conditions (conjunction)\nNOT: negate a filter\nParentheses, ( and ), can be used for grouping.\n\nYou cannot mix different filter categories inside a disjunction (OR). For example, num=3 OR tag1 OR facet:value is not allowed.\n\nYou cannot negate a group of filters, only an individual filter. For example, NOT(filter1 OR filter2) is not allowed.\n\nFor performance reasons, filter expressions are limited to a conjunction (ANDs) of disjunctions (ORs). In other words, you can have ANDs of ORs (e.g. filter1 AND (filter2 OR filter3)), but not ORs of ANDs (e.g. filter1 OR (filter2 AND filter3).\n\nUsage notes:#\nArray Attributes: Any attribute set up as an array will match the filter as soon as one of the values in the array match.\nKeywords are case-sensitive.\nWhen to use quotes (simple or double, depending on the language):\nIf a value or attribute name contains spaces (see example).\nIf a value or attribute name conflicts with a keyword (see example).\nPhrases that includes quotes, like content:\"It's a wonderful day\" (see example).\nPhrases that includes quotes, like attribute:\"She said \"Hello World\"\" (see example).\nNested attributes can be used for filtering, so authors.mainAuthor:\"John Doe\" is a valid filter, as long as authors.mainAuthor is declared as an attributesForFaceting.",
                    "key": "filters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEb": {
                    "doc": "Filter hits by facet value.\n\nThe filters parameter provides an easier to use, SQL-like syntax, and it supports both filters and facets. We recommend using it instead of facetFilters.\n\nUsage notes:#\nFormat: The general format for referencing a facet value is ${attributeName}:${value}. This attribute/value combination represents a filter on a given facet value.\n\nMultiple filters: If you specify multiple filters, they are interpreted as a conjunction (AND). If you want to use a disjunction (OR), use a nested array.\n\n[\"category:Book\", \"author:John Doe\"] translates as category:Book AND author:\"John Doe\".\n[[\"category:Book\", \"category:Movie\"], \"author:John Doe\"] translates as (category:Book OR category:Movie) AND author:\"John Doe\".\nNegation is supported by prefixing the value with a minus sign (-), sometimes called a dash. For example: [\"category:Book\", \"category:-Movie\"] translates as category:Book AND NOT category:Movie.\n\nEscape characters: On the other hand, if your facet value starts with a -, meaning it contains the -, then you can escape the character with a \\ to prevent the engine from interpreting this as a negative facet filter. For example, filtering on category:\\-Movie will filter on all records that have a category equal to ‚Äú-Movie‚Äù.",
                    "key": "facetFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEc": {
                    "doc": "Create filters for ranking purposes, where records that match the filter are ranked highest.\n\nOptional filtering behaves like normal filters, meaning that it returns records that match both the query and the filters. However, it also returns records that do not match the filters. The effect is on the ranking: records matching the filters are ranked higher than records that do not match the filters.\n\nUsage notes:#\nThe boolean syntax is the same as facetFilters, except for negative syntax. If you use negative syntax, for example categories:-Book, it will not work; it will be transformed into categories:Book.\n\nPromoting results: See how you can use optionalFilters to promote filters and facets.\n\nRanking Formula: This setting will only work if the Filters criterion is part of the ranking. Filters is by default part of the ranking; so if you‚Äôve removed it, and yet wish to use option filters, you‚Äôll need to add it back to the ranking formula.\n\nFor customers on the Community, Essential and Plus legacy plans who signed up before December 15, 2018, optional filters are limited to only one per query. Free plans do not have access to optional filters.\n\nFor all other plans (Enterprise, Pro, Starter), optional filters are unlimited.",
                    "key": "optionalFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEd": {
                    "doc": "Filter on numeric attributes.\n\nThe filters parameter provides an easier to use, SQL-like syntax. We recommend using it instead of this setting.\n\nNumeric Comparisons#\n\nFormat: ${attributeName} ${operator} ${operand}\nExample: inStock = 1.\n\nSupported operators are <, <=, =, !=, >= and >, with the same semantics as in virtually all programming languages.\n\nNumeric Range#\n\nFormat: ${attributeName}:${lowerBound} TO ${upperBound}\nExample: price:5.99 TO 100\n\n${lowerBound} and ${upperBound} must be numeric. Both are inclusive.\n\nUsage notes:#\nNo boolean operators: You cannot use boolean operators like AND and OR.\n\nMultiple filters: If you specify multiple filters, they are interpreted as a conjunction (AND). If you want to use a disjunction (OR), use a nested array.",
                    "key": "numericFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEe": {
                    "doc": "Filter hits by tags.\n\ntagFilters is a different way of filtering, which relies on the _tags attribute. It uses a simpler syntax than filters. You can use it when you want to do simple filtering based on tags.\n\nFor more advanced filtering, we recommend the filters parameter instead. Filters can be placed in any attribute, at any level (deep nesting included). Tags can only be contained in a top-level _tags attribute. Additionally, Filters provide an easier to use, SQL-like syntax.\n\nUsage notes:#\n_tags: For this setting to work, your records need to have a _tags attribute.\n\nMultiple filters: If you specify multiple tags, they are interpreted as a conjunction (AND). If you want to use a disjunction (OR), use a nested array.\n\nNegation is supported by prefixing the tag value with a minus sign (-), sometimes called a dash. For example, [\"tag1\", \"-tag2\"] translates as tag1 AND NOT tag2.\n\nNo record count: Tag filtering is used for filtering only. You will not get a count of records that match the filters. In this way, it is the same as using filterOnly() in the attributesForFaceting.",
                    "key": "tagFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEf": {
                    "doc": "Determines how to calculate the total score for filtering.\n\nWhen using filter scoring to rank filtered records, you can control how scores are calculated.\n\nUsage notes:#\nThis feature only applies to OR boolean operators in your filters (ie. not AND).\n\nWhen sumOrFiltersScores is false, max score will be kept.\n\nWhen sumOrFiltersScores is true, score will be summed.\n\nJust to be clear: False means that the total score of a record is the maximum score of an individual filter. Setting it to true changes the total score by adding together the scores of each matched filter.",
                    "key": "sumOrFiltersScores",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEg": {
                    "doc": "Facets to retrieve.\n\nThe effect of this setting: For each of the retrieved facets (eg. color; size), the response will contain a list of facet values (blue, red; small, large, ‚Ä¶) in objects matching the current query. Each value will be returned with its associated count (number of matched objects containing that value).\n\nThe maximum number of facet values returned depends on the maxValuesPerFacet setting. The default is 100 and the max is 1000.\n\nBy default, the returned values are sorted by frequency, but this can be changed to alphabetical with sortFacetValuesBy.\n\nUsage notes:#\nFacets must have been declared beforehand in the attributesForFaceting index setting.\n\nFaceting does not filter your results. If you want to filter results, you should use filters.\n\nDefault/Empty list: If not specified or empty, no facets are retrieved. The value ['*'] retrieves all facets. This forces the engine to avoid aggressive optimizations and improves exhaustivity. This can be useful when your query includes filters.\n\nApproximating facet counts: If the number of hits is high, facet counts may be approximate. The response field exhaustiveFacetsCount is true when the count is exact.",
                    "key": "facets",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEh": {
                    "doc": "Maximum number of facet values to return for each facet during a regular search.\n\nIf you want to change the number of retrieved facet hits during a search for facet values, see maxFacetHits.\n\nUsage notes:#\nFor performance reasons, the API enforces a hard limit of 1000 on maxValuesPerFacet. Any value above that limit will be interpreted as 1000.",
                    "key": "maxValuesPerFacet",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEi": {
                    "doc": "Force faceting to be applied after de-duplication (via the Distinct setting).\n\nWhen using the distinct setting in combination with faceting, facet counts may be higher than expected. This is because the engine, by default, computes faceting before applying de-duplication (distinct). When facetingAfterDistinct is set to true, the engine calculates faceting after the de-duplication has been applied.\n\nUsage notes:#\nYou should not use facetingAfterDistinct=true if you don‚Äôt have the same facet values in all records sharing the same distinct key (you would get inconsistent results).\n\nfacetingAfterDistinct can only be set at query time; it can‚Äôt be added as a default setting of the index.\n\nfacetingAfterDistinct is ignored if you also set typoTolerance to either strict or min.\n\nThe facet count is based on the number of hits the engine finds. This means that when using the distinct parameter to group results (with a numeric value greater than zero), the facet count isn‚Äôt based on the group itself, but on the hits that make up this group.",
                    "key": "facetingAfterDistinct",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEj": {
                    "doc": "Controls how facet values are sorted.\n\nWhen using facets, Algolia retrieves a list of matching facet values for each faceted attribute. This parameter controls how the facet values are sorted within each faceted attribute.\n\nUsage notes:#\nYou can either sort by count (the default, from high to low) or alphabetically\n\nThe set of returned facet values depends on the maximum number of facet values returned, which depends on the maxValuesPerFacet setting. The default is 100 and the max is 1000. Therefore, values with very low frequency could potentially not be returned.\n\nOptions:#\ncount: Facet values are sorted by decreasing count. The count is the number of records containing this facet value in the results of the query.\n\nalpha: Facet values are sorted in alphabetical order, ascending from A to Z.",
                    "key": "sortFacetValuesBy",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEk": {
                    "doc": "List of attributes to highlight.\n\nUsage notes:#\nIf not set, all searchable attributes are highlighted (see searchableAttributes).\nThe special value * may be used to highlight all attributes.\nImpact on the response:#\nWhen highlighting is enabled, each hit in the response will contain an additional _highlightResult object (provided that at least one of its attributes is highlighted) with the following fields:\n\nvalue (string): Markup text with occurrences highlighted. The tags used for highlighting are specified via highlightPreTag and highlightPostTag.\n\nmatchLevel (string, enum) = {none | partial | full}: Indicates how well the attribute matched the search query.\n\nmatchedWords (array): List of words from the query that matched the object.\n\nfullyHighlighted (boolean): Whether the entire attribute value is highlighted.",
                    "key": "attributesToHighlight",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEl": {
                    "doc": "List of attributes to snippet, with an optional maximum number of words to snippet.\n\nUsage notes:#\nThe number of words can be omitted, and defaults to 10.\nIf not set, no attributes are snippeted.\nThe special value * may be used to snippet all attributes.\nImpact on the response:#\nWhen snippeting is enabled, each hit in the response will contain an additional _snippetResult object (provided that at least one of its attributes is snippeted) with the following fields:\n\nvalue (string): Markup text with occurrences highlighted and optional ellipsis indicators. The tags used for highlighting are specified via highlightPreTag and highlightPostTag. The text used to indicate ellipsis is specified via snippetEllipsisText.\n\nmatchLevel (string, enum) = {none | partial | full}: Indicates how well the attribute matched the search query.",
                    "key": "attributesToSnippet",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEm": {
                    "doc": "The HTML string to insert before the highlighted parts in all highlight and snippet results.\n\nUsage notes:#\nhighlightPreTag needs to be used along with highlightPostTag.",
                    "key": "highlightPreTag",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEn": {
                    "doc": "The HTML string to insert after the highlighted parts in all highlight and snippet results.\n\nUsage notes:#\nhighlightPostTag needs to be used along with highlightPreTag.",
                    "key": "highlightPostTag",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEo": {
                    "doc": "String used as an ellipsis indicator when a snippet is truncated.\n\nUsage notes:#\nDefaults to an empty string for all accounts created before February 10th, 2016.\n\nDefaults to \"‚Ä¶\" (U+2026, HORIZONTAL ELLIPSIS) for accounts created after that date.",
                    "key": "snippetEllipsisText",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEp": {
                    "doc": "Restrict highlighting and snippeting to items that matched the query.\n\nImpact on the response:#\nWhen false, all items are highlighted/snippeted\n\nWhen true, only items that matched at least partially are highlighted/snippeted",
                    "key": "restrictHighlightAndSnippetArrays",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEq": {
                    "doc": "Specify the page to retrieve.\n\nYou will need to use this setting if you wish to retrieve specific pages.\n\nUsage notes:#\nPage numbers\n\nPage-numbering is based on the value of hitsPerPage. If hitsPerPage=20, then page=0 will display the hits from 1 to 20, page=2 will display the hits from 41 to 60.\n\nPage numbers are zero-based. Therefore, in order to retrieve the 10th page, you need to set page=9.\n\nIf you send a request for a page that does not exist, or is out-of-range (i.e. when page > nbPages), we do not return an error. Instead, we return 0 results.\n\nExamples",
                    "key": "page",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEr": {
                    "doc": "Set the number of hits per page.\n\nIn most cases, page/hitsPerPage is the recommended method for pagination. Check our full discussion on pagination approaches.\n\nUsage notes:#\nThis can be set at indexing time, as a default. And can be overridden at query time.\n\n1000 is the maximum.",
                    "key": "hitsPerPage",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEs": {
                    "doc": "Offset is the position in the dataset of a particular record. By specifying offset, you retrieve a subset of records starting with the offset value. Offset normally works with length, which determines how many records to retrieve starting from the offset.\n\nUsage notes:#\nOffset is zero-based: the 10th record is at offset 9.\n\nIf you omit length, the number of records returned is equal to the hitsPerPage. In fact, using offset requires that you specify length as well; otherwise, it defaults to page-based pagination.\n\nIf offset is specified, page is ignored.\n\nUsage: If you have 100 records in your result set, and you want to retrieve records 50 to 80, you will need to use offset=49 and length = 30.",
                    "key": "offset",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEt": {
                    "doc": "Set the number of hits to retrieve (used only with offset).\n\nIn most cases, page/hitsPerPage is the recommended method for pagination. This setting is part of an alternative paging approach.\n\nSimilar to hitsPerPage, but works only with offset.\n\nUsage notes:#\n1000 is the maximum.\n\nIf offset is omitted, length is ignored.\n\nOn the other hand, if you specify offset but omit length, the number of records returned is equal to the hitsPerPage. In fact, using offset requires that you specify length as well; otherwise, it defaults to page-based pagination.",
                    "key": "length",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEu": {
                    "doc": "Minimum number of characters a word in the query string must contain to accept matches with 1 typo.",
                    "key": "minWordSizefor1Typo",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEv": {
                    "doc": "Minimum number of characters a word in the query string must contain to accept matches with 2 typos.",
                    "key": "minWordSizefor2Typos",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEw": {
                    "doc": "Controls whether typo tolerance is enabled and how it is applied.\n\nUsage notes:#\nAlgolia never returns records with more than 2 typos.\nIf you use getRankingInfo, you can retrieve the number of typos for each result. Note that you could see 3 typos even with only 2 mistyped letters. This is because Algolia counts a typo on the first letter as 2 typos.\nOptions:#\ntrue: Typo tolerance is enabled and all records matching with or without typos are retrieved (default behavior).\n\nfalse: Typo tolerance is entirely disabled. Only records matching without typos are retrieved.\n\nmin: Retrieve records with the smallest number of typos.\n\nFor example, if the smallest number of typos found is 0, then only records matching without typos will be returned. If the smallest number of typos found is 1, then only records matching with 1 typo will be returned.\n\nstrict: Retrieve records with the 2 smallest number of typos.\n\nFor example, if the smallest number of typos found is 0, then only records matching with 0 or 1 typo will be returned. If the smallest number of typos found is 1, then only records matching with 1 or 2 typos will be returned.\n\nStrict changes the engine‚Äôs ranking, forcing the typo criterion to go the top of the ranking formula.",
                    "key": "typoTolerance",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEx": {
                    "doc": "Whether to allow typos on numbers (‚Äúnumeric tokens‚Äù) in the query string.\n\nThis option can be very useful on numbers with special formatting, like serial numbers and zip codes searches.\n\nUsage notes:#\nWhen false, typo tolerance is disabled on numeric tokens. For example, the query 304 will match 30450 but not 40450 (which would have been the case with typo tolerance enabled).",
                    "key": "allowTyposOnNumericTokens",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEy": {
                    "doc": "List of attributes on which you want to disable typo tolerance.\n\nUsage notes:#\nThe list must be a subset of the searchableAttributes index setting.\n\nsearchableAttributes must not be empty nor null for disableTypoToleranceOnAttributes to be applied.",
                    "key": " minWordSizefor1Typo settings search\t Minimum number of characters a word in the query string must contain to accept matches with 1 typo.  minWordSizefor2Typos settings search\t Minimum number of characters a word in the query string must contain to accept matches with 2 typos.  typoTolerance settings search\t Controls whether typo tolerance is enabled and how it is applied.  allowTyposOnNumericTokens settings search\t Whether to allow typos on numbers (‚Äúnumeric tokens‚Äù) in the query string.  disableTypoToleranceOnAttributes",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEz": {
                    "doc": "Search for entries around a central geolocation, enabling a geo search within a circular area.\n\nBy defining this central point, there are three consequences:\n\na radius / circle is computed automatically, based on the density of the records near the point defined by this setting\nonly records that fall within the bounds of the circle are returned\nrecords are ranked according to the distance from the center of the circle\nUsage notes:#\nWith this setting, you are defining a central point of a circle, whose geo-coordinates are expressed as two floats separated by a comma.\n\nNote: This setting differs from aroundLatLngViaIP, which uses the end-user‚Äôs IP to determine the geo-coordinates.\n\nThis parameter will be ignored if used along with insideBoundingBox or insidePolygon\n\nTo control the maximum size of the radius, you would use aroundRadius.\n\nTo control the minimum size, you would use minimumAroundRadius.\n\nThe size of this radius depends on the density of the area around the central point. If there are a large number of hits close to the central point, the radius can be small. The less hits near the center, the larger the radius will be.\n\nNote: If the results returned are less than the number of hits per page (hitsPerPage), then the number returned will be less than the hitsPerPage. For example, if you recieve 15 results, you could still see a larger number of hits per page, such as hitsPerPage=20.",
                    "key": "aroundLatLng",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFA": {
                    "doc": "Search for entries around a given location automatically computed from the requester‚Äôs IP address.\n\nBy computing a central geolocation (from an IP), this has three consequences:\n\na radius / circle is computed automatically, based on the density of the records near the point defined by this setting\nonly records that fall within the bounds of the circle are returned\nrecords are ranked according to the distance from the center of the circle\nUsage notes:#\nWith this setting, you are using the end-user‚Äôs IP to define a central axis point of a circle in geo-coordinates.\n\nAlgolia automatically calculates the size of the circular radius around this central axis.\n\nTo control the precise size of the radius, you would use aroundRadius.\nTo control a minimum size, you would use minimumAroundRadius.\nIf you are sending the request from your servers, you must set the X-Forwarded-For HTTP header with the front-end-user‚Äôs IP address for it to be used as the basis for the computation of the search location.\n\nNote: This setting differs from aroundLatLng, which allows you to specify the exact latitude and longitude of the center of the circle.\n\nThis parameter will be ignored if used along with insideBoundingBox or insidePolygon\n\nWe currently only support IPv4 addresses. If the end user has an IPv6 address, this parameter won‚Äôt work as intended.",
                    "key": "aroundLatLngViaIP",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFB": {
                    "doc": "Define the maximum radius for a geo search (in meters).\n\nUsage notes:#\nThis setting only works within the context of a radial (circuler) geo search, enabled by aroundLatLngViaIP or aroundLatLng.\n\nHow the radius is calculated:\n\nIf you specify the meters of the radius (instead of all), then only records that fall within the bounds of the circle (as defined by the radius) will be returned. Additionally, the ranking of the returned hits will be based on the distance from the central axist point.\n\nIf you use all, there is no longer any filtering based on the radius. All relevant results are returned, but the ranking is still based on the distance from the central axis point.\n\nIf you do not use this setting, and yet perform a radial geo search (using aroundLatLngViaIP or aroundLatLng), the radius is automatically computed from the density of the searched area. See also minimumAroundRadius, which determines the minimum size of the radius.\n\nFor this setting to have any effect on your ranking, the geo criterion must be included in your ranking formula (which is the case by default).\n\nOptions:#\nradius_in_meters: Integer value (in meters) representing the radius around the coordinates specified during the query.\n\nall: Disables the radius logic, allowing all results to be returned, regardless of distance. Ranking is still based on proximity to the central axis point. This option is faster than specifying a high integer value.",
                    "key": "aroundRadius",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFC": {
                    "doc": "Precision of geo search (in meters), to add grouping by geo location to the ranking formula.\n\nWhen ranking hits, geo distances are grouped into ranges of aroundPrecision size. All hits within the same range are considered equal with respect to the geo ranking parameter.\n\nFor example, if you set aroundPrecision to 100, any two objects lying in the range [0, 99] from the searched location will be considered equal; same for [100, 199], [200, 299], etc.\n\nUsage notes:#\nFor this setting to have any effect, the geo criterion must be included in your ranking formula (which is the case by default).",
                    "key": "aroundPrecision",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFD": {
                    "doc": "Minimum radius (in meters) used for a geo search when aroundRadius is not set.\n\nWhen a radius is automatically generated, the area of the circle might be too small to include enough records. This setting allows you to increase the size of the circle, thus ensuring sufficient coverage.\n\nUsage notes:#\nThis setting only works within the context of a circular geo search, enabled by aroundLatLng or aroundLatLngViaIP.\n\nThis parameter is ignored when aroundRadius is set.",
                    "key": "minimumAroundRadius",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFE": {
                    "doc": "Search inside a rectangular area (in geo coordinates).\n\nThe rectangle is defined by two diagonally opposite points (hereafter p1 and p2), hence by 4 floats: p1Lat, p1Lng, p2Lat, p2Lng.\n\nFor example: insideBoundingBox = [ 47.3165, 4.9665, 47.3424, 5.0201 ]\n\nUsage notes:#\nYou may specify multiple bounding boxes, in which case the search will use the union (OR) of the rectangles. To do this, pass either:\n\nmore than 4 values (must be a multiple of 4: 8, 12‚Ä¶); example: 47.3165,4.9665,47.3424,5.0201,40.9234,2.1185,38.6430,1.9916; or\nan list of lists of floats (each inner array must contain exactly 4 values); example: [[47.3165, 4.9665, 47.3424, 5.0201], [40.9234, 2.1185, 38.6430, 1.9916]].\naroundLatLng and aroundLatLngViaIP will be ignored if used along with this parameter.\n\nBe careful when your coordinates cross over the 180th meridian.",
                    "key": "insideBoundingBox",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFF": {
                    "doc": "Search inside a polygon (in geo coordinates).\n\nA polygon#\nis an unlimited series of points, with a minimum of 3.\n\nA point is a set of 2 floats: latitude, longitude.\n\nThe polygon therefore needs an even number of float values: p1Lat, p1Lng, p2Lat, p2Lng, p3Lat, p3Long.\n\nFor example: insidePolygon=47.3165,4.9665,47.3424,5.0201,47.32,4.98\n\nUsage notes:#\nYou can plot points that are 1 meter apart or 1000s of meters apart. This all depends on the oddness of the shape and its geographical size.\n\nmultiple polygons#\nYou may specify multiple polygons, in which case the search will use the union (OR) of the polygons. To specify multiple polygons, pass an list of lists of floats (each inner array must contain an even number of values, with a minimum of 6); example: [[47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9], [40.9234, 2.1185, 38.6430, 1.9916, 39.2587, 2.0104]].\n\nKeep in mind the purpose of this setting. For example, if you are drawing a circle, you will use instead aroundRadius. If a rectangle, then insideBoundingBox. And so on.\n\naroundLatLng and aroundLatLngViaIP will be ignored if used along with this parameter.\n\nBe careful when your coordinates cross over the 180th meridian.",
                    "key": "insidePolygon",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFG": {
                    "doc": "Treats singular, plurals, and other forms of declensions as matching terms.\n\nThe ignore plurals functionality (explained here in depth) considers the following forms as equivalent - that is, they match even if they are spelled differently:\n\nsingular forms\nplural forms\nany inflected forms due to declensions (for languages where it applies)\nFor example, ‚Äúcar‚Äù and ‚Äúcars‚Äù, or ‚Äúfoot‚Äù and ‚Äúfeet‚Äù, are considered equivalent.\n\nUsage notes:#\nignorePlurals is used in conjunction with the queryLanguages setting.\n\nYou can send ignorePlurals one of 3 values:\n\ntrue, which enables the ignore plurals functionality, where singulars and plurals are considered equivalent (foot = feet). The languages supported here are either every language (this is the default, see list of languages below), or those set by queryLanguages.\n\nfalse, which disables ignore plurals, where singulars and plurals are not considered the same for matching purposes (foot will not find feet).\n\na list of language ISO codes for which ignoring plurals should be enabled. This list will override any values that you may have set in queryLanguages.\n\nFor optimum relevance, it is highly recommended that you enable only languages that are used in your data. Enabling all languages (setting ignorePlurals to true) may have unintended side effects, with pairs of words being unexpectedly treated as equivalent. For example, French word ‚Äúchair‚Äù (which means ‚Äúflesh‚Äù) would find ‚Äúchairs‚Äù in an English index.\n\nList of supported languages with their associated language ISO code:\n\nAfrikaans=af\nArabic=ar\nAzerbaijani=az\nBulgarian=bg\nCatalan=ca\nCzech=cs\nWelsh=cy\nDanish=da\nGerman=de\nEnglish=en\nEsperanto=eo\nSpanish=es\nEstonian=et\nBasque=eu\nFinnish=fi\nFaroese=fo\nFrench=fr\nGalician=gl\nHebrew=he\nHindi=hi\nHungarian=hu\nArmenian=hy\nIndonesian=id\nIcelandic=is\nItalian=it\nJapanese=ja\nGeorgian=ka\nKazakh=kk\nKorean=ko\nKirghiz=ky\nLithuanian=lt\nMaori=mi\nMongolian=mn\nMarathi=mr\nMalay=ms\nMaltese=mt\nNorwegian Bokm√•l=nb\nDutch=nl\nNorwegian=no\nNorthern Sotho=ns\nPolish=pl\nPashto=ps\nPortuguese=pt\nQuechua=qu\nRomanian=ro\nRussian=ru\nSlovak=sk\nAlbanian=sq\nSwedish=sv\nSwahili=sw\nTamil=ta\nTelugu=te\nTagalog=tl\nTswana=tn\nTurkish=tr\nTatar=tt\nUkrainian=uk\nUrdu=ur\nUzbek=uz\nChinese=zh",
                    "key": "ignorePlurals",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFH": {
                    "doc": "Removes stop (common) words from the query before executing it.\n\nStop word removal is useful when you have a query in natural language, e.g. ‚Äúwhat is a record?‚Äù. In that case, the engine will remove ‚Äúwhat‚Äù, ‚Äúis‚Äù, and ‚Äúa‚Äù before executing the query, and therefore just search for ‚Äúrecord‚Äù. This will remove false positives caused by stop words, especially when combined with optional words (see optionalWords and removeWordsIfNoResults).\n\nUsage notes:#\nremoveStopWords is used in conjunction with the queryLanguages setting.\n\nYou can send removeStopWords one of 3 values:\n\ntrue, which enables the stop word functionality, ensuring that stop words are removed from consideration in a search. The languages supported here are either every language (this is the default, see list of languages below), or those set by queryLanguages. See queryLanguages example below.\n\nfalse, which disables stop word functionality, allowing stop words to be taken into account in a search.\n\na list of language ISO codes for which stop words should be enabled. This list will override any values that you may have set in ‚ÄòqueryLanguages`.\n\nFor most use cases, however, it is better not to use this feature, as people tend to search by keywords on search engines (that is, they naturally omit stop words).\n\nPrefix logic: Stop words only apply on query words that are not interpreted as prefixes. To control how prefixes are interpreted, check out queryType.\n\nList of supported languages with their associated ISO code:\n\nArabic=ar\nBulgarian=bg\nBengali=bn\nCatalan=ca\nCzech=cs\nDanish=da\nGerman=de\nGreek=el\nEnglish=en\nSpanish=es\nBasque=eu\nPersian (Farsi)=fa\nFinnish=fi\nFrench=fr\nIrish=ga\nGalician=gl\nHindi=hi\nHungarian=hu\nArmenian=hy\nIndonesian=id\nItalian=it\nJapanese=ja\nKorean=ko\nKurdish=ku\nLithuanian=lt\nLatvian=lv\nMarathi=mr\nDutch=nl\nNorwegian=no\nPolish=pl\nPortuguese=pt\nBrazilian=pt-br\nRomanian=ro\nRussian=ru\nSlovak=sk\nSwedish=sv\nThai=th\nTurkish=tr\nUkranian=uk\nUrdu=ur\nChinese=zh",
                    "key": "removeStopWords",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFI": {
                    "doc": "Sets the languages to be used by language-specific settings and functionalities such as ignorePlurals, removeStopWords, and CJK word-detection.\n\nqueryLanguages performs 2 roles:\n\nIt sets a default list of languages used by removeStopWords and ignorePlurals (if they are enabled). For example, if you enable ignorePlurals, the languages set in queryLanguages will be applied.\n\nIt sets the dictionary for word-detecting in CJK languages (=Chinese ‚Äúzh‚Äù, Japanese ‚Äúja‚Äù, or Korean ‚Äúko‚Äù). For this, you need to place the CJK language first in queryLanguages‚Äôs list of languages. For example, to ensure that Chinese word-recognition is based on a Chinese dictionary, and not the general algorithm used for all languages, you need to place Chinese in the first position of the list of languages. Likewise for Japanese and Korean, they need to be first in the list to ensure proper dictionary-based parsing. See example below.\n\nUsage notes:#\nWhen working with Japanese data, you also need to set ‚Äúja‚Äù in the indexLanguages parameter.\n\nIf you do not use queryLanguages, the engine will use either the system default (all languages) or the list of languages specified directly in ignorePlurals and removeStopWords.\n\nAs already noted, queryLanguages creates a default list of languages. This default that can be overridden by any setting that uses the default. For example, if you set the default to English and French, you can set ignorePlurals to use the default but set removeStopWords to recognize only English stop words. See example below.\n\nFor optimum relevance, it is recommended to only enable languages that are used in your data.\n\nList of supported languages with their associated language ISO code:\n\nAfrikaans=af\nArabic=ar\nAzerbaijani=az\nBulgarian=bg\nBengali=bn\nCatalan=ca\nCzech=cs\nWelsh=cy\nDanish=da\nGerman=de\nGreek=el\nEnglish=en\nEsperanto=eo\nSpanish=es\nEstonian=et\nBasque=eu\nPersian (Farsi)=fa\nFinnish=fi\nFaroese=fo\nFrench=fr\nIrish=ga\nGalician=gl\nHebrew=he\nHindi=hi\nHungarian=hu\nArmenian=hy\nIndonesian=id\nIcelandic=is\nItalian=it\nJapanese=ja\nGeorgian=ka\nKazakh=kk\nKorean=ko\nKurdish=ku\nKirghiz=ky\nLithuanian=lt\nLatvian=lv\nMaori=mi\nMongolian=mn\nMarathi=mr\nMalay=ms\nMaltese=mt\nNorwegian Bokm√•l=nb\nDutch=nl\nNorwegian=no\nNorthern Sotho=ns\nPolish=pl\nPashto=ps\nPortuguese=pt\nBrazilian=pt-br\nQuechua=qu\nRomanian=ro\nRussian=ru\nSlovak=sk\nAlbanian=sq\nSwedish=sv\nSwahili=sw\nTamil=ta\nTelugu=te\nThai=th\nTagalog=tl\nTswana=tn\nTurkish=tr\nTatar=tt\nUkranian=uk\nUrdu=ur\nUzbek=uz\nChinese=zh",
                    "key": "queryLanguages",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFJ": {
                    "doc": "Whether Rules should be globally enabled.\n\nThis is a global switch that affects all Rules.\n\nUsage notes:#\nWhen true, Rules processing is enabled: Rules may match the query.\nWhen false, Rules processing is disabled: no Rule will match the query.",
                    "key": "enableRules",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFK": {
                    "doc": "Enables contextual rules.\n\nProvides a list of contexts for which rules are enabled. Contextual rules matching any of these contexts are activated, as well as generic rules.\n\nUsage notes:#\nWhen empty, only generic rules are activated.\n\nFor performance reasons, you may pass up to 10 different contexts to the API at a time at query time.",
                    "key": "ruleContexts",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFL": {
                    "doc": "Enable the Personalization feature.\n\nThe effect of setting enablePersonalization to true is to take into account user insights to personalize the ranking of records.",
                    "key": "enablePersonalization",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFM": {
                    "doc": "Define the impact of the Personalization feature.\n\nThe personalizationImpact parameter sets the percentage of the impact that personalization has on ranking records.\n\nThis is set at query time and therefore overrides any impact value you had set on your index. The higher the personalizationImpact, the more the results are personalized for the user, and the less the custom ranking is taken into account in ranking records.\n\nUsage notes:#\nThe value must be between 0 and 100 (inclusive).\nThis parameter isn‚Äôt taken into account if enablePersonalization is false.\n\nSetting personalizationImpact to 0 disables the Personalization feature, as if enablePersonalization were false.",
                    "key": "personalizationImpact",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFN": {
                    "doc": "Associates a certain user token with the current search.\n\nSending a user token will associate a search with a certain user. The insights taken from this could be used in combination with personalization for example. The user token has to be an alpha-numeric string with a maximum amount of 64 characters.",
                    "key": "userToken",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFO": {
                    "doc": "Controls if and how query words are interpreted as prefixes.\n\nOptions:#\nprefixLast: Only the last word is interpreted as a prefix (default behavior).\n\nprefixAll: All query words are interpreted as prefixes. This option is not recommended, as it tends to yield counterintuitive results and has a negative impact on performance.\n\nprefixNone: No query word is interpreted as a prefix. This option is not recommended, especially in an instant search setup, as the user will have to type the entire word(s) before getting any relevant results.",
                    "key": "queryType",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFP": {
                    "doc": "Selects a strategy to remove words from the query when it doesn‚Äôt match any hits.\n\nThe goal is to avoid empty results by progressively loosening the query until hits are matched.\n\nOptions:#\nnone: No specific processing is done when a query does not return any results (default behavior).\n\nlastWords: When a query does not return any results, treat the last word as optional. The process is repeated with words N-1, N-2, etc. until there are results, or at most 5 words have been removed.\n\nfirstWords: When a query does not return any results, treat the first word as optional. The process is repeated with words 2, 3, etc. until there are results, or at most 5 words have been removed.\n\nallOptional: When a query does not return any results, make a second attempt treating all words as optional. This is equivalent to transforming the implicit AND operator applied between query words to an OR.",
                    "key": "removeWordsIfNoResults",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFQ": {
                    "doc": "Enables the advanced query syntax.\n\nThis advanced syntax brings two additional features:\n\nPhrase query: a specific sequence of terms that must be matched next to one another. A phrase query needs to be surrounded by double quotes (\"). For example, \"search engine\" will only match records having search next to engine.\n\nNote: Typo tolerance is disabled inside the phrase (i.e. within the quotes).\n\nProhibit operator: excludes records that contain a specific term. This term has to be prefixed by a minus (-). For example, search -engine will only match records containing search but not engine.",
                    "key": "advancedSyntax",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFR": {
                    "doc": "A list of words that should be considered as optional when found in the query.\n\nNormally, in order for a record to match it must match all words in the query. By creating a list of optional words, you are also matching records that match only some of the words.\n\nThis impacts ranking as follows:\n\nrecords that match all words are ranked higher\nrecords that match only some words are ranked lower\nUsage notes:#\nThis invariably leads to a larger response.\n\nThis is a strategy to improve a response with little or no results.\n\nYou don‚Äôt need to put commas between words. Each string will automatically be tokenized into words, all of which will be considered as optional.\n\nThis parameter is often used in the context of empty or insufficient results. See discussion here. An alternative to optional words is to use removeWordsIfNoResults. See discussion here.",
                    "key": "optionalWords",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFS": {
                    "doc": "List of attributes on which you want to disable the exact ranking criterion.\n\nUsage notes:#\nThe list must be a subset of the searchableAttributes index setting.\n\nsearchableAttributes must not be empty nor null for disableExactOnAttributes to be applied.",
                    "key": "disableExactOnAttributes",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFT": {
                    "doc": "Controls how the exact ranking criterion is computed when the query contains only one word.\n\nUsage notes:#\nIf exactOnSingleWordQuery is set to word, only exact matches will be highlighted in the _highlightResult property of the search response: partials and prefixes will not be.\n\nOptions:#\nattribute: (default): The exact ranking criterion is set to 1 if the query matches exactly an entire attribute value.\n\nFor example, if you search for the TV show ‚ÄúRoad‚Äù, and in your dataset you have 2 records, ‚ÄúRoad‚Äù and ‚ÄúRoad Trip‚Äù, only the record with ‚ÄúRoad‚Äù is considered exact.\n\nnone: The exact ranking criterion is ignored on single word queries.\n\nword: The exact ranking criterion is set to 1 if the query word is found in the record. The query word must be at least 3 characters long and must not be a stop word in any supported language.\n\nContinuing with our ‚ÄúRoad‚Äù TV show example, in this case, both ‚ÄúRoad‚Äù and ‚ÄúRoad Trip‚Äù are considered to match exactly.",
                    "key": "exactOnSingleWordQuery settings search",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFU": {
                    "doc": "List of alternatives that should be considered an exact match by the exact ranking criterion.\n\nOptions:#\nignorePlurals: Alternative words added by the ignorePlurals feature.\n\nsingleWordSynonym: Single-word synonyms (example: ‚ÄúNY‚Äù = ‚ÄúNYC‚Äù).\n\nmultiWordsSynonym: Multiple-words synonyms (example: ‚ÄúNY‚Äù = ‚ÄúNew York‚Äù).",
                    "key": "alternativesAsExact",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFV": {
                    "doc": "Allows you to specify which advanced syntax features are active when ‚ÄòadvancedSyntax‚Äô is enabled.\n\nBy default, when advancedSyntax is set to true, all advanced syntax features are enabled.\n\nWith this setting, you can disable one or more advanced syntax features.\n\nFor example, you can allow users to do exact phrasing (putting words within quotes), but not allow them to exclude words. Example.\n\nOr you can allow users to exclude words (with a ‚Äò-‚Äò) but not do exact phrasing. Example.\n\nSee advancedSyntax for more information on its features and usage.\n\nOptions:#\nexactPhrase: A specific sequence of terms that must be matched next to one another. A phrase query needs to be surrounded by double quotes (\"). For example, \"search engine\" will only match records having search next to engine.\n\nNote: Typo tolerance is disabled inside the phrase (i.e. within the quotes).\n\nexcludeWords: Excludes records that contain a specific term. This term has to be prefixed by a minus (-). For example, search -engine will only match records containing search but not engine.",
                    "key": "advancedSyntaxFeatures",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFW": {
                    "doc": "Enables de-duplication or grouping of results.\n\nDistinct functionality is based on one attribute, as defined in attributeForDistinct. Using this attribute, you can limit the number of returned records that contain the same value in that attribute.\n\nFor example, if the distinct attribute is show_name and several hits (episodes) have the same value for show_name (for example ‚Äúgame of thrones‚Äù)\n\nif distinct is set to 1 (de-duplication):\n\nthen only the most relevant episode is kept (with respect to the ranking formula); the others are not returned. The direct effect of this is to remove redundant records from your results.\nif distinct is set to N > 1 (grouping):\n\nthen the N most relevant episodes for every show are kept, with similar consequences.\nUsage notes:#\nFor this setting to work, you need to set the distinct attribute in attributeForDistinct.\n\nWhen set to 1, you enable de-duplication, in which only the most relevant result is returned for all records that have the same value in the distinct attribute. This is similar to the SQL distinct keyword.\n\nWhen set to N (where N > 1), you enable grouping, in which most N hits will be returned with the same value for the distinct attribute.\n\nIf no distinct attribute is configured, distinct will be accepted at query time but silently ignored.\n\nA 0 value disables de-duplication and grouping.\n\nWhen using grouping (when distinct > 1):\n\nthe hitsPerPage parameter controls the number of groups that are returned. In the case of jobs and associated companies, if hitsPerPage=10 and distinct=3, up to 30 records will be returned - 10 companies and at most 3 jobs per company. This behavior makes it easy to implement pagination with grouping.\nthe nbHits attribute in the response contains the number of groups.\nKeep in mind\n\nDistinct is a computationally expensive operation on large data sets, especially if distinct > 1\ndistinct(true) is the same as distinct(1)\ndistinct(false) is the same as distinct(0), which is the same thing as not specifying distinct at all",
                    "key": "distinct",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFX": {
                    "doc": "Retrieve detailed ranking information.\n\nThis setting lets you see exactly which ranking criteria played a role in selecting each record.\n\nImpact on the response:#\nWhen true, each hit in the response contains an additional _rankingInfo object, which contains the following fields, all at the same level.\n\nTextual relevance / Ranking\n\nnbTypos (integer): Number of typos encountered when matching the record. Corresponds to the typos ranking criterion in the ranking formula.\n\nfirstMatchedWord (integer): Contains 2 pieces of information - the searchable attribute that best matched the query and the character position within that attribute.\nTo determine which attribute within the list of searchableAttributes was the best match, you need to divide the number by 1000: (int) (firstMatchedWord / 1000). For example, if firstMatchedWord=2001, (int) (2001/1000)=2, the best matching attribute is the 3rd one in the list of searchableAttributes (2 = position 3).\nTo calculate the character position within the best matching attribute, you need to extract the remainder of the division using the modulo function of your programming language, such as firstMatchedWord % 1000. For example, if firstMatchedWord=2001, (2001 % 1000)=1, the match began at the 2nd position within the best matching attribute (1 = position 2). Recall that character position only concerns unorderd attributes. For ordered attributes, firstMatchedWord will always be an even thousand (0, 1000, 2000, etc), that is, there will be no remainder. This is because the position of the match does not matter in the ranking, algolia will always consider it to be in the first position. For more on searchable attributes modifiers, go here.\nproximityDistance (integer): The sum of the distances between matched words when the query contains more than one word. Corresponds to the proximity criterion in the ranking formula.\n\nuserScore (integer): Custom ranking for the object, expressed as a single numerical value. This field is internal to Algolia and shouldn‚Äôt be relied upon.\n\nnbExactWords (integer): Number of exactly matched words. If alternativesAsExact is set, it may include plurals and/or synonyms.\n\nwords (integer): Number of matched words in the query, including prefixes and typos.\n\nfilters (integer): This field is reserved for advanced usage. It will be zero in most cases.\n\npromoted (boolean): Present and set to true if a Rule promoted the hit.\nGeo search (see how these are used)\n\ngeoDistance (integer): Distance between the geo location in the search query and the best matching geo location in the record, divided by the geo precision.\n\ngeoPrecision (integer): Precision used when computed the geo distance, in meters. All distances will be floored to a multiple of this precision.\n\nmatchedGeoLocation (array): Contains the latitude, longitude, and distance (in meters) from a central axis point.\n\nAdditional information\n\nserverUsed (string): Actual host name of the server that processed the request. (Our DNS supports automatic failover and load balancing, so this may differ from the host name used in the request.)\n\nindexUsed (string): Index name used for the query. In case of A/B testing, the index returned here is the one that was actually used, either index A (the target) or B (the variant).\n\nabTestVariantID (integer): In case of A/B testing, returns the ID of the variant used. The variant ID is the position in the array of variants (starting at 1).\n\nparsedQuery (string): The query string that will be searched, after normalization. Normalization includes removing stop words (if removeStopWords is enabled), and transforming portions of the query string into phrase queries (see advancedSyntax).\n\ntimeoutCounts (boolean): Whether a timeout was hit when computing the facet counts. When true, the counts will be interpolated (i.e. approximate). See also exhaustiveFacetsCount.\n\ntimeoutHits (boolean): Whether a timeout was hit when retrieving the hits. When true, some results may be missing.",
                    "key": "getRankingInfo",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFY": {
                    "doc": "Enable the Click Analytics feature.\n\nThe effect of setting clickAnalytics to true is to add a queryID to the search response. As explained here, this queryID can subsequently be used in click and conversion analytics.\n\nUsage notes:#\nThis parameter does not, on its own, add any new analytics data; it only ensures that a queryID is returned. With that queryID, it will be up to you then to choose the best events to send as clicks and conversions. See Analytics Implementation Overview.\n\nWhat you can do with Analytics depends on your plan.",
                    "key": "clickAnalytics",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFZ": {
                    "doc": "Whether the current query will be taken into account in the Analytics.\n\nUsage notes:#\nAlgolia captures analytics on every search. This is the default setting. Therefore, this setting‚Äôs primary use is to turn analytics off for a given query.",
                    "key": "analytics",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFa": {
                    "doc": "List of tags to apply to the query for analytics purposes.\n\nYou can use tags in analytics to filter searches. For example, you can send two different tags - mobile and website - to see how mobile users search in comparison to website users.\n\nThere are a couple of limitations to keep in mind when sending analytics tags:\n\nTags can be up to 100 characters long. Longer tags are ignored.\nTags starting with alg# are reserved for internal usage and are ignored.\nA query has a maximum of 10 unique tags. Extra tags are ignored.\nA maximum of 3,500 unique tags combinations is processed per 5-minute window. All extra tags are ignored. A tags combination is the list of tags found in a query. For example, sending 3 queries, each respectively tagged with platform:ios, lang:en, and platform:ios,lang:en, counts as 3 combinations.",
                    "key": "analyticsTags",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFb": {
                    "doc": "Whether to take into account an index‚Äôs synonyms for a particular search.\n\nThis setting overrides the default query behavior, which is to use all defined synonyms on every search. By setting this to false, you are disabling synonyms for the given query. True is the engine default.",
                    "key": "synonyms",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFc": {
                    "doc": "Whether to highlight and snippet the original word that matches the synonym or the synonym itself.\n\nFor example, let‚Äôs say you set up home as a synonym for house, and the user types home. Synonym logic will match any record that contains ‚Äòhouse‚Äô with the synonym ‚Äòhome‚Äô. This setting will replace the word ‚Äòhouse‚Äô with ‚Äòhome‚Äô in the response. The effect of this is that all highlighting and snippeting will be on the synonym ‚Äòhome‚Äô. Without this setting, the original word ‚Äòhouse‚Äô would have been returned and highlighted and snippeted.\n\nUsage notes:#\nWhen true, highlighting and snippeting will use words from the query rather than the original words from the objects.\n\nWhen false, highlighting and snippeting will always display the original words from the objects.\n\nMultiple words can be replaced by a one-word synonym, but not the other way round. For example, if ‚ÄúNYC‚Äù and ‚ÄúNew York City‚Äù are synonyms, searching for ‚ÄúNYC‚Äù will replace ‚ÄúNew York City‚Äù with ‚ÄúNYC‚Äù in highlights and snippets, but searching for ‚ÄúNew York City‚Äù will not replace ‚ÄúNYC‚Äù with ‚ÄúNew York City‚Äù in highlights and snippets.",
                    "key": "replaceSynonymsInHighlight",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFd": {
                    "doc": "Precision of the proximity ranking criterion.\n\nUsage notes:#\nThe minimum (and best) proximity value between two matching words is 1. This is the engine default.\n\nSetting it to 2 (respectively N) would allow 1 (respectively N-1) additional word(s) to be found between two matching words without degrading the proximity ranking value.\n\nFor example, consider the query ‚Äújavascript framework‚Äù. If you set minProximity to 2, two records containing respectively ‚ÄúJavaScript framework‚Äù and ‚ÄúJavaScript charting framework‚Äù will get the same proximity score, even if the latter contains an additional word between the two matching words.\n\nThe maximum value for minProximity is 7. Any higher value will disable the proximity criterion in the ranking formula.",
                    "key": "minProximity",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFe": {
                    "doc": "Choose which fields the response will contain. Applies to search and browse queries.\n\nThis parameter is mainly intended to limit the response size. For example, in complex queries, echoing of request parameters in the response‚Äôs params field can be undesirable.\n\nUsage notes:#\nBy default, all fields are returned. If this parameter is specified, only the fields explicitly listed will be returned, unless * is used, in which case all fields are returned. Specifying an empty list or unknown field names is an error.\n\nList of fields that can be filtered out:\n\naroundLatLng\nautomaticRadius\nexhaustiveFacetsCount\nfacets\nfacets_stats\nhits\nhitsPerPage\nindex\nlength\nnbHits\nnbPages\noffset\npage\nparams\nprocessingTimeMS\nquery\nqueryAfterRemoval\nuserData\nList of fields that cannot be filtered out:\n\nmessage\nwarning\ncursor\nserverUsed\nindexUsed\nabTestVariantID\ntimeoutCounts (deprecated, please use exhaustiveFacetsCount instead)\ntimeoutHits (deprecated, please use exhaustiveFacetsCount instead)\nparsedQuery\nall fields triggered by getRankingInfo",
                    "key": "responseFields",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFf": {
                    "doc": "Maximum number of facet hits to return during a search for facet values.\n\nIf you want to change the number of retrieved facet values for a regular search, see maxValuesPerFacet.\n\nUsage notes:#\nDoes not apply to regular search queries.\n\nFor performance reasons, the maximum allowed number of returned values is 100. Any value outside the range [1, 100] will be rejected.",
                    "key": "maxFacetHits",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFg": {
                    "doc": "Whether to include or exclude a query from the processing-time percentile computation.\n\nUsage notes:#\nWhen true, the API saves the processing time of the search query and includes it when computing the 90% and 99% percentiles, available in your Algolia dashboard.\n\nWhen false, the search query is excluded from the percentile computation.",
                    "key": "percentileComputation",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFh": {
                    "doc": "When attribute is ranked above proximity in your ranking formula, proximity is used to select which searchable attribute is matched in the attribute ranking stage.\n\nUsage notes:#\nThis parameter can only impact relevance when attribute comes before proximity in the ranking formula. By default, this isn‚Äôt the case. The rationale for ranking proximity above attribute is detailed in the ranking criteria section. Generally, for objects with long text sections and a clear searchable attribute order (like documentation), it can be beneficial to rank by attribute before proximity.\n\nattributeCriteriaComputedByMinProximity works in the following way: By default, searches that match multiple searchable attributes are ranked by their best matching attribute (depending on searchable attributes order). However, if you set this parameter to true, the matched attribute is selected based on minimum proximity. In other words, if a search query matches on an object in multiple, different searchable attributes, the one with the smallest proximity is selected.\n\nFor example, consider an index of books, where you have set your searchable attributes to title, author, and description (in that order), and where you‚Äôve changed the ranking formula so that attribute comes before proximity. If the search for a book matches on both its title, with a proximity of 6, and description, with a proximity of 1, then title remains the best matching attribute even though description has a better proximity score. Setting attributeCriteriaComputedByMinProximity to true computes the best matching attribute based on minimum proximity; in our case, description is used instead of title.",
                    "key": "attributeCriteriaComputedByMinProximity",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFi": {
                    "doc": "Whether this search should participate in running AB tests.\n\nUsage notes:#\nBy default, a search participates in currently active AB tests. You can prevent this by setting the enableABTest parameter to false. You may want to do this for searches performed in closed environments (like administration panels), or for searches that must target specific index variants during testing or development.",
                    "key": "enableABTest",
                    "optional": true,
                    "private": true,
                    "value": ""
                }
            },
            "publish_as": "data",
            "rank": 0,
            "ret_value": "api.1579418404674x846189550255734800.plugin_api.AFk",
            "types": "{\"plugin_api.AFk\":{\"caption\":\"üîçSearchIndex\",\"fields\":{\"_p_hits\":{\"ret_value\":\"list.api.1579418404674x846189550255734800.plugin_api.AFk.hits\",\"caption\":\"hits\",\"path\":[\"hits\"]},\"_p_nbHits\":{\"ret_value\":\"number\",\"caption\":\"nbHits\",\"path\":[\"nbHits\"]},\"_p_page\":{\"ret_value\":\"number\",\"caption\":\"page\",\"path\":[\"page\"]},\"_p_nbPages\":{\"ret_value\":\"number\",\"caption\":\"nbPages\",\"path\":[\"nbPages\"]},\"_p_hitsPerPage\":{\"ret_value\":\"number\",\"caption\":\"hitsPerPage\",\"path\":[\"hitsPerPage\"]},\"_p_exhaustiveNbHits\":{\"ret_value\":\"boolean\",\"caption\":\"exhaustiveNbHits\",\"path\":[\"exhaustiveNbHits\"]},\"_p_query\":{\"ret_value\":\"text\",\"caption\":\"query\",\"path\":[\"query\"]},\"_p_params\":{\"ret_value\":\"text\",\"caption\":\"params\",\"path\":[\"params\"]},\"_p_processingTimeMS\":{\"ret_value\":\"number\",\"caption\":\"processingTimeMS\",\"path\":[\"processingTimeMS\"]}}},\"plugin_api.AFk.hits\":{\"caption\":\"üîçSearchIndex hit\",\"fields\":{\"_p_user_signed_up\":{\"ret_value\":\"_ignore\"},\"_p_üìùDescription\":{\"ret_value\":\"_ignore\"},\"_p_üî°PageName\":{\"ret_value\":\"_ignore\"},\"_p_üòáSelfieUrl\":{\"ret_value\":\"_ignore\"},\"_p_üíÄDisabledAccount\":{\"ret_value\":\"_ignore\"},\"_p_üîìPrivate\":{\"ret_value\":\"_ignore\"},\"_p_üî†Name\":{\"ret_value\":\"_ignore\"},\"_p_üòéSelfiePose\":{\"ret_value\":\"_ignore\"},\"_p_üî†NameEdit\":{\"ret_value\":\"_ignore\"},\"_p_üìùDescriptionEdit\":{\"ret_value\":\"_ignore\"},\"_p__id\":{\"ret_value\":\"text\",\"caption\":\"_id\",\"path\":[\"_id\"]},\"_p_objectID\":{\"ret_value\":\"text\",\"caption\":\"objectID\",\"path\":[\"objectID\"]},\"_p__highlightResult.üìùDescription.value\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üìùDescription.matchLevel\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üìùDescription.fullyHighlighted\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üìùDescription.matchedWords\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üî°PageName.value\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üî°PageName.matchLevel\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üòáSelfieUrl.value\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üòáSelfieUrl.matchLevel\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üòéSelfiePose.value\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üòéSelfiePose.matchLevel\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üìùDescriptionEdit.value\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üìùDescriptionEdit.matchLevel\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üìùDescriptionEdit.fullyHighlighted\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult.üìùDescriptionEdit.matchedWords\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult._id.value\":{\"ret_value\":\"_ignore\"},\"_p__highlightResult._id.matchLevel\":{\"ret_value\":\"_ignore\"}}}}",
            "url": "https://[üî†AppId]-dsn.algolia.net/1/indexes/[üî†IndexName]",
            "url_params": {
                "ABG": {
                    "doc": "Identifies which application you are accessing.",
                    "key": "üî†AppId",
                    "private": true,
                    "value": ""
                },
                "ABv": {
                    "doc": "Identifies which index you are accessing.",
                    "key": "üî†IndexName",
                    "private": true,
                    "value": ""
                }
            }
        },
        "AGH": {
            "0": "A",
            "1": "G",
            "2": "G",
            "body": "",
            "doc_link": "https://www.algolia.com/doc/rest-api/search/#browse-index-post",
            "initialized": true,
            "method": "get",
            "name": "üîçBrowseIndex",
            "params": {
                "ADO": {
                    "doc": "Overrides the query parameter and performs a more generic search that can be used to find ‚Äúsimilar‚Äù results.\n\nUsage notes:#\nsimilarQuery should be constructed from the tags and keywords of the object you are trying to find related results to.\n\nsimilarQuery is not automatically generated. You need to select which keywords you think would be useful. For example, a similarQuery for a movie could use the genre, principle actors, and tags attributes. After extracting information from those categories, you might end up with a similarQuery that looks like: ‚ÄúRomance Comedy Gordon-Levitt NY‚Äù. Check out the examples section for a more detailed walk-through.\n\nUse of this parameter changes the search settings in four ways:\n\nSets queryType to prefixNone (no prefix match).\nmatched prefixes are not counted as word matches.\nSets removeStopWords to true.\nstop words like ‚Äòthe‚Äô, ‚Äòa‚Äô, ‚Äòan‚Äô are removed.\nTreats all remaining words (all non-stopwords) as optional.\nobjects that match any word in similarQuery will be returned.\nnote, your similarQuery will likely invoke the caveat behavior of the optionalWords parameter!\nSets words to be the first ranking criteria\nthe number of exactly matching words is the first ranking criteria.\nNote, because the optionalWords parameter (which is leveraged by similarQuery) can yield a high volume of results, you should add filters and optional filters to your similar searches.",
                    "key": "similarQuery",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "ADP": {
                    "doc": "Gives control over which attributes to retrieve and which not to retrieve.\n\nYou don‚Äôt always need to retrieve a full response that includes every attribute in your index. Sometimes you may only want to receive the most relevant attributes, or exclude attributes used only for internal purposes.\n\nThis setting helps reduce your response size and improve performance.\n\nUsage notes:#\nSpecial Characters:\nUse * to retrieve all values.\n\nAppend a dash (-) to an attribute that you do NOT wish to retrieve. Example below. Without prefixing an attribute with -, the attribute will be retrieved.\n\nNote that negative attributes (-) only work when using *. For example, [‚Äú*‚Äù, ‚Äú-title‚Äù] retrieves every attribute except ‚Äútitle‚Äù.\n\nobjectID is always retrieved, even when not specified.\n\nAlso note that using negative attributes doesn‚Äôt make them unsearchable. If your users make queries that match an attribute not to retrieve, they will still get the same results, but the attribute won‚Äôt be part of the response.\n\nAttributes listed in unretrievableAttributes will not be retrieved even if requested, unless the request is authenticated with the admin API key.",
                    "key": "attributesToRetrieve",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEZ": {
                    "doc": "Restricts a given query to look in only a subset of your searchable attributes.\n\nThis setting overrides searchableAttributes for specific searches.\n\nUsage notes:#\nThis setting is a query-level setting, affecting only the search that specifies it.\nsearchableAttributes must not be empty nor null for restrictSearchableAttributes to be applied.",
                    "key": "restrictSearchableAttributes",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEa": {
                    "doc": "Filter the query with numeric, facet and/or tag filters.\n\nThis parameter uses SQL-like syntax, where you can use boolean operators and parentheses to combine individual filters.\n\nNote that each attribute you use in filters must be defined as a facet. The _tags attribute is automatically defined as a facet.\n\nNumeric Comparisons#\n\nFormat: ${attributeName} ${operator} ${value}\nExample: price > 12.99\n\nThe ${value} must be numeric. Supported operators are <, <=, =, !=, >= and >, with the same semantics as in virtually all programming languages.\n\nNumeric Range#\n\nFormat: ${attributeName}:${lowerBound} TO ${upperBound}\nExample: price:5.99 TO 100\n\n${lowerBound} and ${upperBound} must be numeric. Both are inclusive.\n\nFacet filters#\n\nFormat: ${facetName}:${facetValue}\nExample: category:Book\n\nFacet matching is not case sensitive.\n\nWhen ${facetName} contains string values, it needs to be declared inside attributesForFaceting\n\nTag filters#\n\nFormat: _tags:${value} (or, alternatively, just ${value})\nExample: _tags:published\n\nTag matching is case sensitive.\n\nIf no attribute name is specified, the filter applies to _tags. For example: public OR user_42 will translate into _tags:public OR _tags:user_42.\n\nBoolean filters\n\nFormat: facetName:${boolean_value}\nExample: isEnabled:true\n\nWhen ${facetName} needs to be declared inside attributesForFaceting\n\nBoolean operators#\n\nExample:\n\nprice < 10 AND (category:Book OR NOT category:Ebook)\nIndividual filters can be combined via boolean operators. The following operators are supported:\n\nOR: must match any of the combined conditions (disjunction)\nAND: must match all of the combined conditions (conjunction)\nNOT: negate a filter\nParentheses, ( and ), can be used for grouping.\n\nYou cannot mix different filter categories inside a disjunction (OR). For example, num=3 OR tag1 OR facet:value is not allowed.\n\nYou cannot negate a group of filters, only an individual filter. For example, NOT(filter1 OR filter2) is not allowed.\n\nFor performance reasons, filter expressions are limited to a conjunction (ANDs) of disjunctions (ORs). In other words, you can have ANDs of ORs (e.g. filter1 AND (filter2 OR filter3)), but not ORs of ANDs (e.g. filter1 OR (filter2 AND filter3).\n\nUsage notes:#\nArray Attributes: Any attribute set up as an array will match the filter as soon as one of the values in the array match.\nKeywords are case-sensitive.\nWhen to use quotes (simple or double, depending on the language):\nIf a value or attribute name contains spaces (see example).\nIf a value or attribute name conflicts with a keyword (see example).\nPhrases that includes quotes, like content:\"It's a wonderful day\" (see example).\nPhrases that includes quotes, like attribute:\"She said \"Hello World\"\" (see example).\nNested attributes can be used for filtering, so authors.mainAuthor:\"John Doe\" is a valid filter, as long as authors.mainAuthor is declared as an attributesForFaceting.",
                    "key": "filters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEb": {
                    "doc": "Filter hits by facet value.\n\nThe filters parameter provides an easier to use, SQL-like syntax, and it supports both filters and facets. We recommend using it instead of facetFilters.\n\nUsage notes:#\nFormat: The general format for referencing a facet value is ${attributeName}:${value}. This attribute/value combination represents a filter on a given facet value.\n\nMultiple filters: If you specify multiple filters, they are interpreted as a conjunction (AND). If you want to use a disjunction (OR), use a nested array.\n\n[\"category:Book\", \"author:John Doe\"] translates as category:Book AND author:\"John Doe\".\n[[\"category:Book\", \"category:Movie\"], \"author:John Doe\"] translates as (category:Book OR category:Movie) AND author:\"John Doe\".\nNegation is supported by prefixing the value with a minus sign (-), sometimes called a dash. For example: [\"category:Book\", \"category:-Movie\"] translates as category:Book AND NOT category:Movie.\n\nEscape characters: On the other hand, if your facet value starts with a -, meaning it contains the -, then you can escape the character with a \\ to prevent the engine from interpreting this as a negative facet filter. For example, filtering on category:\\-Movie will filter on all records that have a category equal to ‚Äú-Movie‚Äù.",
                    "key": "facetFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEc": {
                    "doc": "Create filters for ranking purposes, where records that match the filter are ranked highest.\n\nOptional filtering behaves like normal filters, meaning that it returns records that match both the query and the filters. However, it also returns records that do not match the filters. The effect is on the ranking: records matching the filters are ranked higher than records that do not match the filters.\n\nUsage notes:#\nThe boolean syntax is the same as facetFilters, except for negative syntax. If you use negative syntax, for example categories:-Book, it will not work; it will be transformed into categories:Book.\n\nPromoting results: See how you can use optionalFilters to promote filters and facets.\n\nRanking Formula: This setting will only work if the Filters criterion is part of the ranking. Filters is by default part of the ranking; so if you‚Äôve removed it, and yet wish to use option filters, you‚Äôll need to add it back to the ranking formula.\n\nFor customers on the Community, Essential and Plus legacy plans who signed up before December 15, 2018, optional filters are limited to only one per query. Free plans do not have access to optional filters.\n\nFor all other plans (Enterprise, Pro, Starter), optional filters are unlimited.",
                    "key": "optionalFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEd": {
                    "doc": "Filter on numeric attributes.\n\nThe filters parameter provides an easier to use, SQL-like syntax. We recommend using it instead of this setting.\n\nNumeric Comparisons#\n\nFormat: ${attributeName} ${operator} ${operand}\nExample: inStock = 1.\n\nSupported operators are <, <=, =, !=, >= and >, with the same semantics as in virtually all programming languages.\n\nNumeric Range#\n\nFormat: ${attributeName}:${lowerBound} TO ${upperBound}\nExample: price:5.99 TO 100\n\n${lowerBound} and ${upperBound} must be numeric. Both are inclusive.\n\nUsage notes:#\nNo boolean operators: You cannot use boolean operators like AND and OR.\n\nMultiple filters: If you specify multiple filters, they are interpreted as a conjunction (AND). If you want to use a disjunction (OR), use a nested array.",
                    "key": "numericFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEe": {
                    "doc": "Filter hits by tags.\n\ntagFilters is a different way of filtering, which relies on the _tags attribute. It uses a simpler syntax than filters. You can use it when you want to do simple filtering based on tags.\n\nFor more advanced filtering, we recommend the filters parameter instead. Filters can be placed in any attribute, at any level (deep nesting included). Tags can only be contained in a top-level _tags attribute. Additionally, Filters provide an easier to use, SQL-like syntax.\n\nUsage notes:#\n_tags: For this setting to work, your records need to have a _tags attribute.\n\nMultiple filters: If you specify multiple tags, they are interpreted as a conjunction (AND). If you want to use a disjunction (OR), use a nested array.\n\nNegation is supported by prefixing the tag value with a minus sign (-), sometimes called a dash. For example, [\"tag1\", \"-tag2\"] translates as tag1 AND NOT tag2.\n\nNo record count: Tag filtering is used for filtering only. You will not get a count of records that match the filters. In this way, it is the same as using filterOnly() in the attributesForFaceting.",
                    "key": "tagFilters",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEf": {
                    "doc": "Determines how to calculate the total score for filtering.\n\nWhen using filter scoring to rank filtered records, you can control how scores are calculated.\n\nUsage notes:#\nThis feature only applies to OR boolean operators in your filters (ie. not AND).\n\nWhen sumOrFiltersScores is false, max score will be kept.\n\nWhen sumOrFiltersScores is true, score will be summed.\n\nJust to be clear: False means that the total score of a record is the maximum score of an individual filter. Setting it to true changes the total score by adding together the scores of each matched filter.",
                    "key": "sumOrFiltersScores",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEg": {
                    "doc": "Facets to retrieve.\n\nThe effect of this setting: For each of the retrieved facets (eg. color; size), the response will contain a list of facet values (blue, red; small, large, ‚Ä¶) in objects matching the current query. Each value will be returned with its associated count (number of matched objects containing that value).\n\nThe maximum number of facet values returned depends on the maxValuesPerFacet setting. The default is 100 and the max is 1000.\n\nBy default, the returned values are sorted by frequency, but this can be changed to alphabetical with sortFacetValuesBy.\n\nUsage notes:#\nFacets must have been declared beforehand in the attributesForFaceting index setting.\n\nFaceting does not filter your results. If you want to filter results, you should use filters.\n\nDefault/Empty list: If not specified or empty, no facets are retrieved. The value ['*'] retrieves all facets. This forces the engine to avoid aggressive optimizations and improves exhaustivity. This can be useful when your query includes filters.\n\nApproximating facet counts: If the number of hits is high, facet counts may be approximate. The response field exhaustiveFacetsCount is true when the count is exact.",
                    "key": "facets",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEh": {
                    "doc": "Maximum number of facet values to return for each facet during a regular search.\n\nIf you want to change the number of retrieved facet hits during a search for facet values, see maxFacetHits.\n\nUsage notes:#\nFor performance reasons, the API enforces a hard limit of 1000 on maxValuesPerFacet. Any value above that limit will be interpreted as 1000.",
                    "key": "maxValuesPerFacet",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEi": {
                    "doc": "Force faceting to be applied after de-duplication (via the Distinct setting).\n\nWhen using the distinct setting in combination with faceting, facet counts may be higher than expected. This is because the engine, by default, computes faceting before applying de-duplication (distinct). When facetingAfterDistinct is set to true, the engine calculates faceting after the de-duplication has been applied.\n\nUsage notes:#\nYou should not use facetingAfterDistinct=true if you don‚Äôt have the same facet values in all records sharing the same distinct key (you would get inconsistent results).\n\nfacetingAfterDistinct can only be set at query time; it can‚Äôt be added as a default setting of the index.\n\nfacetingAfterDistinct is ignored if you also set typoTolerance to either strict or min.\n\nThe facet count is based on the number of hits the engine finds. This means that when using the distinct parameter to group results (with a numeric value greater than zero), the facet count isn‚Äôt based on the group itself, but on the hits that make up this group.",
                    "key": "facetingAfterDistinct",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEj": {
                    "doc": "Controls how facet values are sorted.\n\nWhen using facets, Algolia retrieves a list of matching facet values for each faceted attribute. This parameter controls how the facet values are sorted within each faceted attribute.\n\nUsage notes:#\nYou can either sort by count (the default, from high to low) or alphabetically\n\nThe set of returned facet values depends on the maximum number of facet values returned, which depends on the maxValuesPerFacet setting. The default is 100 and the max is 1000. Therefore, values with very low frequency could potentially not be returned.\n\nOptions:#\ncount: Facet values are sorted by decreasing count. The count is the number of records containing this facet value in the results of the query.\n\nalpha: Facet values are sorted in alphabetical order, ascending from A to Z.",
                    "key": "sortFacetValuesBy",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEk": {
                    "doc": "List of attributes to highlight.\n\nUsage notes:#\nIf not set, all searchable attributes are highlighted (see searchableAttributes).\nThe special value * may be used to highlight all attributes.\nImpact on the response:#\nWhen highlighting is enabled, each hit in the response will contain an additional _highlightResult object (provided that at least one of its attributes is highlighted) with the following fields:\n\nvalue (string): Markup text with occurrences highlighted. The tags used for highlighting are specified via highlightPreTag and highlightPostTag.\n\nmatchLevel (string, enum) = {none | partial | full}: Indicates how well the attribute matched the search query.\n\nmatchedWords (array): List of words from the query that matched the object.\n\nfullyHighlighted (boolean): Whether the entire attribute value is highlighted.",
                    "key": "attributesToHighlight",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEl": {
                    "doc": "List of attributes to snippet, with an optional maximum number of words to snippet.\n\nUsage notes:#\nThe number of words can be omitted, and defaults to 10.\nIf not set, no attributes are snippeted.\nThe special value * may be used to snippet all attributes.\nImpact on the response:#\nWhen snippeting is enabled, each hit in the response will contain an additional _snippetResult object (provided that at least one of its attributes is snippeted) with the following fields:\n\nvalue (string): Markup text with occurrences highlighted and optional ellipsis indicators. The tags used for highlighting are specified via highlightPreTag and highlightPostTag. The text used to indicate ellipsis is specified via snippetEllipsisText.\n\nmatchLevel (string, enum) = {none | partial | full}: Indicates how well the attribute matched the search query.",
                    "key": "attributesToSnippet",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEm": {
                    "doc": "The HTML string to insert before the highlighted parts in all highlight and snippet results.\n\nUsage notes:#\nhighlightPreTag needs to be used along with highlightPostTag.",
                    "key": "highlightPreTag",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEn": {
                    "doc": "The HTML string to insert after the highlighted parts in all highlight and snippet results.\n\nUsage notes:#\nhighlightPostTag needs to be used along with highlightPreTag.",
                    "key": "highlightPostTag",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEo": {
                    "doc": "String used as an ellipsis indicator when a snippet is truncated.\n\nUsage notes:#\nDefaults to an empty string for all accounts created before February 10th, 2016.\n\nDefaults to \"‚Ä¶\" (U+2026, HORIZONTAL ELLIPSIS) for accounts created after that date.",
                    "key": "snippetEllipsisText",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEp": {
                    "doc": "Restrict highlighting and snippeting to items that matched the query.\n\nImpact on the response:#\nWhen false, all items are highlighted/snippeted\n\nWhen true, only items that matched at least partially are highlighted/snippeted",
                    "key": "restrictHighlightAndSnippetArrays",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEq": {
                    "doc": "Specify the page to retrieve.\n\nYou will need to use this setting if you wish to retrieve specific pages.\n\nUsage notes:#\nPage numbers\n\nPage-numbering is based on the value of hitsPerPage. If hitsPerPage=20, then page=0 will display the hits from 1 to 20, page=2 will display the hits from 41 to 60.\n\nPage numbers are zero-based. Therefore, in order to retrieve the 10th page, you need to set page=9.\n\nIf you send a request for a page that does not exist, or is out-of-range (i.e. when page > nbPages), we do not return an error. Instead, we return 0 results.\n\nExamples",
                    "key": "page",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEr": {
                    "doc": "Set the number of hits per page.\n\nIn most cases, page/hitsPerPage is the recommended method for pagination. Check our full discussion on pagination approaches.\n\nUsage notes:#\nThis can be set at indexing time, as a default. And can be overridden at query time.\n\n1000 is the maximum.",
                    "key": "hitsPerPage",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEs": {
                    "doc": "Offset is the position in the dataset of a particular record. By specifying offset, you retrieve a subset of records starting with the offset value. Offset normally works with length, which determines how many records to retrieve starting from the offset.\n\nUsage notes:#\nOffset is zero-based: the 10th record is at offset 9.\n\nIf you omit length, the number of records returned is equal to the hitsPerPage. In fact, using offset requires that you specify length as well; otherwise, it defaults to page-based pagination.\n\nIf offset is specified, page is ignored.\n\nUsage: If you have 100 records in your result set, and you want to retrieve records 50 to 80, you will need to use offset=49 and length = 30.",
                    "key": "offset",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEt": {
                    "doc": "Set the number of hits to retrieve (used only with offset).\n\nIn most cases, page/hitsPerPage is the recommended method for pagination. This setting is part of an alternative paging approach.\n\nSimilar to hitsPerPage, but works only with offset.\n\nUsage notes:#\n1000 is the maximum.\n\nIf offset is omitted, length is ignored.\n\nOn the other hand, if you specify offset but omit length, the number of records returned is equal to the hitsPerPage. In fact, using offset requires that you specify length as well; otherwise, it defaults to page-based pagination.",
                    "key": "length",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEu": {
                    "doc": "Minimum number of characters a word in the query string must contain to accept matches with 1 typo.",
                    "key": "minWordSizefor1Typo",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEv": {
                    "doc": "Minimum number of characters a word in the query string must contain to accept matches with 2 typos.",
                    "key": "minWordSizefor2Typos",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEw": {
                    "doc": "Controls whether typo tolerance is enabled and how it is applied.\n\nUsage notes:#\nAlgolia never returns records with more than 2 typos.\nIf you use getRankingInfo, you can retrieve the number of typos for each result. Note that you could see 3 typos even with only 2 mistyped letters. This is because Algolia counts a typo on the first letter as 2 typos.\nOptions:#\ntrue: Typo tolerance is enabled and all records matching with or without typos are retrieved (default behavior).\n\nfalse: Typo tolerance is entirely disabled. Only records matching without typos are retrieved.\n\nmin: Retrieve records with the smallest number of typos.\n\nFor example, if the smallest number of typos found is 0, then only records matching without typos will be returned. If the smallest number of typos found is 1, then only records matching with 1 typo will be returned.\n\nstrict: Retrieve records with the 2 smallest number of typos.\n\nFor example, if the smallest number of typos found is 0, then only records matching with 0 or 1 typo will be returned. If the smallest number of typos found is 1, then only records matching with 1 or 2 typos will be returned.\n\nStrict changes the engine‚Äôs ranking, forcing the typo criterion to go the top of the ranking formula.",
                    "key": "typoTolerance",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEx": {
                    "doc": "Whether to allow typos on numbers (‚Äúnumeric tokens‚Äù) in the query string.\n\nThis option can be very useful on numbers with special formatting, like serial numbers and zip codes searches.\n\nUsage notes:#\nWhen false, typo tolerance is disabled on numeric tokens. For example, the query 304 will match 30450 but not 40450 (which would have been the case with typo tolerance enabled).",
                    "key": "allowTyposOnNumericTokens",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEy": {
                    "doc": "List of attributes on which you want to disable typo tolerance.\n\nUsage notes:#\nThe list must be a subset of the searchableAttributes index setting.\n\nsearchableAttributes must not be empty nor null for disableTypoToleranceOnAttributes to be applied.",
                    "key": " minWordSizefor1Typo settings search\t Minimum number of characters a word in the query string must contain to accept matches with 1 typo.  minWordSizefor2Typos settings search\t Minimum number of characters a word in the query string must contain to accept matches with 2 typos.  typoTolerance settings search\t Controls whether typo tolerance is enabled and how it is applied.  allowTyposOnNumericTokens settings search\t Whether to allow typos on numbers (‚Äúnumeric tokens‚Äù) in the query string.  disableTypoToleranceOnAttributes",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AEz": {
                    "doc": "Search for entries around a central geolocation, enabling a geo search within a circular area.\n\nBy defining this central point, there are three consequences:\n\na radius / circle is computed automatically, based on the density of the records near the point defined by this setting\nonly records that fall within the bounds of the circle are returned\nrecords are ranked according to the distance from the center of the circle\nUsage notes:#\nWith this setting, you are defining a central point of a circle, whose geo-coordinates are expressed as two floats separated by a comma.\n\nNote: This setting differs from aroundLatLngViaIP, which uses the end-user‚Äôs IP to determine the geo-coordinates.\n\nThis parameter will be ignored if used along with insideBoundingBox or insidePolygon\n\nTo control the maximum size of the radius, you would use aroundRadius.\n\nTo control the minimum size, you would use minimumAroundRadius.\n\nThe size of this radius depends on the density of the area around the central point. If there are a large number of hits close to the central point, the radius can be small. The less hits near the center, the larger the radius will be.\n\nNote: If the results returned are less than the number of hits per page (hitsPerPage), then the number returned will be less than the hitsPerPage. For example, if you recieve 15 results, you could still see a larger number of hits per page, such as hitsPerPage=20.",
                    "key": "aroundLatLng",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFA": {
                    "doc": "Search for entries around a given location automatically computed from the requester‚Äôs IP address.\n\nBy computing a central geolocation (from an IP), this has three consequences:\n\na radius / circle is computed automatically, based on the density of the records near the point defined by this setting\nonly records that fall within the bounds of the circle are returned\nrecords are ranked according to the distance from the center of the circle\nUsage notes:#\nWith this setting, you are using the end-user‚Äôs IP to define a central axis point of a circle in geo-coordinates.\n\nAlgolia automatically calculates the size of the circular radius around this central axis.\n\nTo control the precise size of the radius, you would use aroundRadius.\nTo control a minimum size, you would use minimumAroundRadius.\nIf you are sending the request from your servers, you must set the X-Forwarded-For HTTP header with the front-end-user‚Äôs IP address for it to be used as the basis for the computation of the search location.\n\nNote: This setting differs from aroundLatLng, which allows you to specify the exact latitude and longitude of the center of the circle.\n\nThis parameter will be ignored if used along with insideBoundingBox or insidePolygon\n\nWe currently only support IPv4 addresses. If the end user has an IPv6 address, this parameter won‚Äôt work as intended.",
                    "key": "aroundLatLngViaIP",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFB": {
                    "doc": "Define the maximum radius for a geo search (in meters).\n\nUsage notes:#\nThis setting only works within the context of a radial (circuler) geo search, enabled by aroundLatLngViaIP or aroundLatLng.\n\nHow the radius is calculated:\n\nIf you specify the meters of the radius (instead of all), then only records that fall within the bounds of the circle (as defined by the radius) will be returned. Additionally, the ranking of the returned hits will be based on the distance from the central axist point.\n\nIf you use all, there is no longer any filtering based on the radius. All relevant results are returned, but the ranking is still based on the distance from the central axis point.\n\nIf you do not use this setting, and yet perform a radial geo search (using aroundLatLngViaIP or aroundLatLng), the radius is automatically computed from the density of the searched area. See also minimumAroundRadius, which determines the minimum size of the radius.\n\nFor this setting to have any effect on your ranking, the geo criterion must be included in your ranking formula (which is the case by default).\n\nOptions:#\nradius_in_meters: Integer value (in meters) representing the radius around the coordinates specified during the query.\n\nall: Disables the radius logic, allowing all results to be returned, regardless of distance. Ranking is still based on proximity to the central axis point. This option is faster than specifying a high integer value.",
                    "key": "aroundRadius",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFC": {
                    "doc": "Precision of geo search (in meters), to add grouping by geo location to the ranking formula.\n\nWhen ranking hits, geo distances are grouped into ranges of aroundPrecision size. All hits within the same range are considered equal with respect to the geo ranking parameter.\n\nFor example, if you set aroundPrecision to 100, any two objects lying in the range [0, 99] from the searched location will be considered equal; same for [100, 199], [200, 299], etc.\n\nUsage notes:#\nFor this setting to have any effect, the geo criterion must be included in your ranking formula (which is the case by default).",
                    "key": "aroundPrecision",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFD": {
                    "doc": "Minimum radius (in meters) used for a geo search when aroundRadius is not set.\n\nWhen a radius is automatically generated, the area of the circle might be too small to include enough records. This setting allows you to increase the size of the circle, thus ensuring sufficient coverage.\n\nUsage notes:#\nThis setting only works within the context of a circular geo search, enabled by aroundLatLng or aroundLatLngViaIP.\n\nThis parameter is ignored when aroundRadius is set.",
                    "key": "minimumAroundRadius",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFE": {
                    "doc": "Search inside a rectangular area (in geo coordinates).\n\nThe rectangle is defined by two diagonally opposite points (hereafter p1 and p2), hence by 4 floats: p1Lat, p1Lng, p2Lat, p2Lng.\n\nFor example: insideBoundingBox = [ 47.3165, 4.9665, 47.3424, 5.0201 ]\n\nUsage notes:#\nYou may specify multiple bounding boxes, in which case the search will use the union (OR) of the rectangles. To do this, pass either:\n\nmore than 4 values (must be a multiple of 4: 8, 12‚Ä¶); example: 47.3165,4.9665,47.3424,5.0201,40.9234,2.1185,38.6430,1.9916; or\nan list of lists of floats (each inner array must contain exactly 4 values); example: [[47.3165, 4.9665, 47.3424, 5.0201], [40.9234, 2.1185, 38.6430, 1.9916]].\naroundLatLng and aroundLatLngViaIP will be ignored if used along with this parameter.\n\nBe careful when your coordinates cross over the 180th meridian.",
                    "key": "insideBoundingBox",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFF": {
                    "doc": "Search inside a polygon (in geo coordinates).\n\nA polygon#\nis an unlimited series of points, with a minimum of 3.\n\nA point is a set of 2 floats: latitude, longitude.\n\nThe polygon therefore needs an even number of float values: p1Lat, p1Lng, p2Lat, p2Lng, p3Lat, p3Long.\n\nFor example: insidePolygon=47.3165,4.9665,47.3424,5.0201,47.32,4.98\n\nUsage notes:#\nYou can plot points that are 1 meter apart or 1000s of meters apart. This all depends on the oddness of the shape and its geographical size.\n\nmultiple polygons#\nYou may specify multiple polygons, in which case the search will use the union (OR) of the polygons. To specify multiple polygons, pass an list of lists of floats (each inner array must contain an even number of values, with a minimum of 6); example: [[47.3165, 4.9665, 47.3424, 5.0201, 47.32, 4.9], [40.9234, 2.1185, 38.6430, 1.9916, 39.2587, 2.0104]].\n\nKeep in mind the purpose of this setting. For example, if you are drawing a circle, you will use instead aroundRadius. If a rectangle, then insideBoundingBox. And so on.\n\naroundLatLng and aroundLatLngViaIP will be ignored if used along with this parameter.\n\nBe careful when your coordinates cross over the 180th meridian.",
                    "key": "insidePolygon",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFG": {
                    "doc": "Treats singular, plurals, and other forms of declensions as matching terms.\n\nThe ignore plurals functionality (explained here in depth) considers the following forms as equivalent - that is, they match even if they are spelled differently:\n\nsingular forms\nplural forms\nany inflected forms due to declensions (for languages where it applies)\nFor example, ‚Äúcar‚Äù and ‚Äúcars‚Äù, or ‚Äúfoot‚Äù and ‚Äúfeet‚Äù, are considered equivalent.\n\nUsage notes:#\nignorePlurals is used in conjunction with the queryLanguages setting.\n\nYou can send ignorePlurals one of 3 values:\n\ntrue, which enables the ignore plurals functionality, where singulars and plurals are considered equivalent (foot = feet). The languages supported here are either every language (this is the default, see list of languages below), or those set by queryLanguages.\n\nfalse, which disables ignore plurals, where singulars and plurals are not considered the same for matching purposes (foot will not find feet).\n\na list of language ISO codes for which ignoring plurals should be enabled. This list will override any values that you may have set in queryLanguages.\n\nFor optimum relevance, it is highly recommended that you enable only languages that are used in your data. Enabling all languages (setting ignorePlurals to true) may have unintended side effects, with pairs of words being unexpectedly treated as equivalent. For example, French word ‚Äúchair‚Äù (which means ‚Äúflesh‚Äù) would find ‚Äúchairs‚Äù in an English index.\n\nList of supported languages with their associated language ISO code:\n\nAfrikaans=af\nArabic=ar\nAzerbaijani=az\nBulgarian=bg\nCatalan=ca\nCzech=cs\nWelsh=cy\nDanish=da\nGerman=de\nEnglish=en\nEsperanto=eo\nSpanish=es\nEstonian=et\nBasque=eu\nFinnish=fi\nFaroese=fo\nFrench=fr\nGalician=gl\nHebrew=he\nHindi=hi\nHungarian=hu\nArmenian=hy\nIndonesian=id\nIcelandic=is\nItalian=it\nJapanese=ja\nGeorgian=ka\nKazakh=kk\nKorean=ko\nKirghiz=ky\nLithuanian=lt\nMaori=mi\nMongolian=mn\nMarathi=mr\nMalay=ms\nMaltese=mt\nNorwegian Bokm√•l=nb\nDutch=nl\nNorwegian=no\nNorthern Sotho=ns\nPolish=pl\nPashto=ps\nPortuguese=pt\nQuechua=qu\nRomanian=ro\nRussian=ru\nSlovak=sk\nAlbanian=sq\nSwedish=sv\nSwahili=sw\nTamil=ta\nTelugu=te\nTagalog=tl\nTswana=tn\nTurkish=tr\nTatar=tt\nUkrainian=uk\nUrdu=ur\nUzbek=uz\nChinese=zh",
                    "key": "ignorePlurals",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFH": {
                    "doc": "Removes stop (common) words from the query before executing it.\n\nStop word removal is useful when you have a query in natural language, e.g. ‚Äúwhat is a record?‚Äù. In that case, the engine will remove ‚Äúwhat‚Äù, ‚Äúis‚Äù, and ‚Äúa‚Äù before executing the query, and therefore just search for ‚Äúrecord‚Äù. This will remove false positives caused by stop words, especially when combined with optional words (see optionalWords and removeWordsIfNoResults).\n\nUsage notes:#\nremoveStopWords is used in conjunction with the queryLanguages setting.\n\nYou can send removeStopWords one of 3 values:\n\ntrue, which enables the stop word functionality, ensuring that stop words are removed from consideration in a search. The languages supported here are either every language (this is the default, see list of languages below), or those set by queryLanguages. See queryLanguages example below.\n\nfalse, which disables stop word functionality, allowing stop words to be taken into account in a search.\n\na list of language ISO codes for which stop words should be enabled. This list will override any values that you may have set in ‚ÄòqueryLanguages`.\n\nFor most use cases, however, it is better not to use this feature, as people tend to search by keywords on search engines (that is, they naturally omit stop words).\n\nPrefix logic: Stop words only apply on query words that are not interpreted as prefixes. To control how prefixes are interpreted, check out queryType.\n\nList of supported languages with their associated ISO code:\n\nArabic=ar\nBulgarian=bg\nBengali=bn\nCatalan=ca\nCzech=cs\nDanish=da\nGerman=de\nGreek=el\nEnglish=en\nSpanish=es\nBasque=eu\nPersian (Farsi)=fa\nFinnish=fi\nFrench=fr\nIrish=ga\nGalician=gl\nHindi=hi\nHungarian=hu\nArmenian=hy\nIndonesian=id\nItalian=it\nJapanese=ja\nKorean=ko\nKurdish=ku\nLithuanian=lt\nLatvian=lv\nMarathi=mr\nDutch=nl\nNorwegian=no\nPolish=pl\nPortuguese=pt\nBrazilian=pt-br\nRomanian=ro\nRussian=ru\nSlovak=sk\nSwedish=sv\nThai=th\nTurkish=tr\nUkranian=uk\nUrdu=ur\nChinese=zh",
                    "key": "removeStopWords",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFI": {
                    "doc": "Sets the languages to be used by language-specific settings and functionalities such as ignorePlurals, removeStopWords, and CJK word-detection.\n\nqueryLanguages performs 2 roles:\n\nIt sets a default list of languages used by removeStopWords and ignorePlurals (if they are enabled). For example, if you enable ignorePlurals, the languages set in queryLanguages will be applied.\n\nIt sets the dictionary for word-detecting in CJK languages (=Chinese ‚Äúzh‚Äù, Japanese ‚Äúja‚Äù, or Korean ‚Äúko‚Äù). For this, you need to place the CJK language first in queryLanguages‚Äôs list of languages. For example, to ensure that Chinese word-recognition is based on a Chinese dictionary, and not the general algorithm used for all languages, you need to place Chinese in the first position of the list of languages. Likewise for Japanese and Korean, they need to be first in the list to ensure proper dictionary-based parsing. See example below.\n\nUsage notes:#\nWhen working with Japanese data, you also need to set ‚Äúja‚Äù in the indexLanguages parameter.\n\nIf you do not use queryLanguages, the engine will use either the system default (all languages) or the list of languages specified directly in ignorePlurals and removeStopWords.\n\nAs already noted, queryLanguages creates a default list of languages. This default that can be overridden by any setting that uses the default. For example, if you set the default to English and French, you can set ignorePlurals to use the default but set removeStopWords to recognize only English stop words. See example below.\n\nFor optimum relevance, it is recommended to only enable languages that are used in your data.\n\nList of supported languages with their associated language ISO code:\n\nAfrikaans=af\nArabic=ar\nAzerbaijani=az\nBulgarian=bg\nBengali=bn\nCatalan=ca\nCzech=cs\nWelsh=cy\nDanish=da\nGerman=de\nGreek=el\nEnglish=en\nEsperanto=eo\nSpanish=es\nEstonian=et\nBasque=eu\nPersian (Farsi)=fa\nFinnish=fi\nFaroese=fo\nFrench=fr\nIrish=ga\nGalician=gl\nHebrew=he\nHindi=hi\nHungarian=hu\nArmenian=hy\nIndonesian=id\nIcelandic=is\nItalian=it\nJapanese=ja\nGeorgian=ka\nKazakh=kk\nKorean=ko\nKurdish=ku\nKirghiz=ky\nLithuanian=lt\nLatvian=lv\nMaori=mi\nMongolian=mn\nMarathi=mr\nMalay=ms\nMaltese=mt\nNorwegian Bokm√•l=nb\nDutch=nl\nNorwegian=no\nNorthern Sotho=ns\nPolish=pl\nPashto=ps\nPortuguese=pt\nBrazilian=pt-br\nQuechua=qu\nRomanian=ro\nRussian=ru\nSlovak=sk\nAlbanian=sq\nSwedish=sv\nSwahili=sw\nTamil=ta\nTelugu=te\nThai=th\nTagalog=tl\nTswana=tn\nTurkish=tr\nTatar=tt\nUkranian=uk\nUrdu=ur\nUzbek=uz\nChinese=zh",
                    "key": "queryLanguages",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFJ": {
                    "doc": "Whether Rules should be globally enabled.\n\nThis is a global switch that affects all Rules.\n\nUsage notes:#\nWhen true, Rules processing is enabled: Rules may match the query.\nWhen false, Rules processing is disabled: no Rule will match the query.",
                    "key": "enableRules",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFK": {
                    "doc": "Enables contextual rules.\n\nProvides a list of contexts for which rules are enabled. Contextual rules matching any of these contexts are activated, as well as generic rules.\n\nUsage notes:#\nWhen empty, only generic rules are activated.\n\nFor performance reasons, you may pass up to 10 different contexts to the API at a time at query time.",
                    "key": "ruleContexts",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFL": {
                    "doc": "Enable the Personalization feature.\n\nThe effect of setting enablePersonalization to true is to take into account user insights to personalize the ranking of records.",
                    "key": "enablePersonalization",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFM": {
                    "doc": "Define the impact of the Personalization feature.\n\nThe personalizationImpact parameter sets the percentage of the impact that personalization has on ranking records.\n\nThis is set at query time and therefore overrides any impact value you had set on your index. The higher the personalizationImpact, the more the results are personalized for the user, and the less the custom ranking is taken into account in ranking records.\n\nUsage notes:#\nThe value must be between 0 and 100 (inclusive).\nThis parameter isn‚Äôt taken into account if enablePersonalization is false.\n\nSetting personalizationImpact to 0 disables the Personalization feature, as if enablePersonalization were false.",
                    "key": "personalizationImpact",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFN": {
                    "doc": "Associates a certain user token with the current search.\n\nSending a user token will associate a search with a certain user. The insights taken from this could be used in combination with personalization for example. The user token has to be an alpha-numeric string with a maximum amount of 64 characters.",
                    "key": "userToken",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFO": {
                    "doc": "Controls if and how query words are interpreted as prefixes.\n\nOptions:#\nprefixLast: Only the last word is interpreted as a prefix (default behavior).\n\nprefixAll: All query words are interpreted as prefixes. This option is not recommended, as it tends to yield counterintuitive results and has a negative impact on performance.\n\nprefixNone: No query word is interpreted as a prefix. This option is not recommended, especially in an instant search setup, as the user will have to type the entire word(s) before getting any relevant results.",
                    "key": "queryType",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFP": {
                    "doc": "Selects a strategy to remove words from the query when it doesn‚Äôt match any hits.\n\nThe goal is to avoid empty results by progressively loosening the query until hits are matched.\n\nOptions:#\nnone: No specific processing is done when a query does not return any results (default behavior).\n\nlastWords: When a query does not return any results, treat the last word as optional. The process is repeated with words N-1, N-2, etc. until there are results, or at most 5 words have been removed.\n\nfirstWords: When a query does not return any results, treat the first word as optional. The process is repeated with words 2, 3, etc. until there are results, or at most 5 words have been removed.\n\nallOptional: When a query does not return any results, make a second attempt treating all words as optional. This is equivalent to transforming the implicit AND operator applied between query words to an OR.",
                    "key": "removeWordsIfNoResults",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFQ": {
                    "doc": "Enables the advanced query syntax.\n\nThis advanced syntax brings two additional features:\n\nPhrase query: a specific sequence of terms that must be matched next to one another. A phrase query needs to be surrounded by double quotes (\"). For example, \"search engine\" will only match records having search next to engine.\n\nNote: Typo tolerance is disabled inside the phrase (i.e. within the quotes).\n\nProhibit operator: excludes records that contain a specific term. This term has to be prefixed by a minus (-). For example, search -engine will only match records containing search but not engine.",
                    "key": "advancedSyntax",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFR": {
                    "doc": "A list of words that should be considered as optional when found in the query.\n\nNormally, in order for a record to match it must match all words in the query. By creating a list of optional words, you are also matching records that match only some of the words.\n\nThis impacts ranking as follows:\n\nrecords that match all words are ranked higher\nrecords that match only some words are ranked lower\nUsage notes:#\nThis invariably leads to a larger response.\n\nThis is a strategy to improve a response with little or no results.\n\nYou don‚Äôt need to put commas between words. Each string will automatically be tokenized into words, all of which will be considered as optional.\n\nThis parameter is often used in the context of empty or insufficient results. See discussion here. An alternative to optional words is to use removeWordsIfNoResults. See discussion here.",
                    "key": "optionalWords",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFS": {
                    "doc": "List of attributes on which you want to disable the exact ranking criterion.\n\nUsage notes:#\nThe list must be a subset of the searchableAttributes index setting.\n\nsearchableAttributes must not be empty nor null for disableExactOnAttributes to be applied.",
                    "key": "disableExactOnAttributes",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFT": {
                    "doc": "Controls how the exact ranking criterion is computed when the query contains only one word.\n\nUsage notes:#\nIf exactOnSingleWordQuery is set to word, only exact matches will be highlighted in the _highlightResult property of the search response: partials and prefixes will not be.\n\nOptions:#\nattribute: (default): The exact ranking criterion is set to 1 if the query matches exactly an entire attribute value.\n\nFor example, if you search for the TV show ‚ÄúRoad‚Äù, and in your dataset you have 2 records, ‚ÄúRoad‚Äù and ‚ÄúRoad Trip‚Äù, only the record with ‚ÄúRoad‚Äù is considered exact.\n\nnone: The exact ranking criterion is ignored on single word queries.\n\nword: The exact ranking criterion is set to 1 if the query word is found in the record. The query word must be at least 3 characters long and must not be a stop word in any supported language.\n\nContinuing with our ‚ÄúRoad‚Äù TV show example, in this case, both ‚ÄúRoad‚Äù and ‚ÄúRoad Trip‚Äù are considered to match exactly.",
                    "key": "exactOnSingleWordQuery settings search",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFU": {
                    "doc": "List of alternatives that should be considered an exact match by the exact ranking criterion.\n\nOptions:#\nignorePlurals: Alternative words added by the ignorePlurals feature.\n\nsingleWordSynonym: Single-word synonyms (example: ‚ÄúNY‚Äù = ‚ÄúNYC‚Äù).\n\nmultiWordsSynonym: Multiple-words synonyms (example: ‚ÄúNY‚Äù = ‚ÄúNew York‚Äù).",
                    "key": "alternativesAsExact",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFV": {
                    "doc": "Allows you to specify which advanced syntax features are active when ‚ÄòadvancedSyntax‚Äô is enabled.\n\nBy default, when advancedSyntax is set to true, all advanced syntax features are enabled.\n\nWith this setting, you can disable one or more advanced syntax features.\n\nFor example, you can allow users to do exact phrasing (putting words within quotes), but not allow them to exclude words. Example.\n\nOr you can allow users to exclude words (with a ‚Äò-‚Äò) but not do exact phrasing. Example.\n\nSee advancedSyntax for more information on its features and usage.\n\nOptions:#\nexactPhrase: A specific sequence of terms that must be matched next to one another. A phrase query needs to be surrounded by double quotes (\"). For example, \"search engine\" will only match records having search next to engine.\n\nNote: Typo tolerance is disabled inside the phrase (i.e. within the quotes).\n\nexcludeWords: Excludes records that contain a specific term. This term has to be prefixed by a minus (-). For example, search -engine will only match records containing search but not engine.",
                    "key": "advancedSyntaxFeatures",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFX": {
                    "doc": "Retrieve detailed ranking information.\n\nThis setting lets you see exactly which ranking criteria played a role in selecting each record.\n\nImpact on the response:#\nWhen true, each hit in the response contains an additional _rankingInfo object, which contains the following fields, all at the same level.\n\nTextual relevance / Ranking\n\nnbTypos (integer): Number of typos encountered when matching the record. Corresponds to the typos ranking criterion in the ranking formula.\n\nfirstMatchedWord (integer): Contains 2 pieces of information - the searchable attribute that best matched the query and the character position within that attribute.\nTo determine which attribute within the list of searchableAttributes was the best match, you need to divide the number by 1000: (int) (firstMatchedWord / 1000). For example, if firstMatchedWord=2001, (int) (2001/1000)=2, the best matching attribute is the 3rd one in the list of searchableAttributes (2 = position 3).\nTo calculate the character position within the best matching attribute, you need to extract the remainder of the division using the modulo function of your programming language, such as firstMatchedWord % 1000. For example, if firstMatchedWord=2001, (2001 % 1000)=1, the match began at the 2nd position within the best matching attribute (1 = position 2). Recall that character position only concerns unorderd attributes. For ordered attributes, firstMatchedWord will always be an even thousand (0, 1000, 2000, etc), that is, there will be no remainder. This is because the position of the match does not matter in the ranking, algolia will always consider it to be in the first position. For more on searchable attributes modifiers, go here.\nproximityDistance (integer): The sum of the distances between matched words when the query contains more than one word. Corresponds to the proximity criterion in the ranking formula.\n\nuserScore (integer): Custom ranking for the object, expressed as a single numerical value. This field is internal to Algolia and shouldn‚Äôt be relied upon.\n\nnbExactWords (integer): Number of exactly matched words. If alternativesAsExact is set, it may include plurals and/or synonyms.\n\nwords (integer): Number of matched words in the query, including prefixes and typos.\n\nfilters (integer): This field is reserved for advanced usage. It will be zero in most cases.\n\npromoted (boolean): Present and set to true if a Rule promoted the hit.\nGeo search (see how these are used)\n\ngeoDistance (integer): Distance between the geo location in the search query and the best matching geo location in the record, divided by the geo precision.\n\ngeoPrecision (integer): Precision used when computed the geo distance, in meters. All distances will be floored to a multiple of this precision.\n\nmatchedGeoLocation (array): Contains the latitude, longitude, and distance (in meters) from a central axis point.\n\nAdditional information\n\nserverUsed (string): Actual host name of the server that processed the request. (Our DNS supports automatic failover and load balancing, so this may differ from the host name used in the request.)\n\nindexUsed (string): Index name used for the query. In case of A/B testing, the index returned here is the one that was actually used, either index A (the target) or B (the variant).\n\nabTestVariantID (integer): In case of A/B testing, returns the ID of the variant used. The variant ID is the position in the array of variants (starting at 1).\n\nparsedQuery (string): The query string that will be searched, after normalization. Normalization includes removing stop words (if removeStopWords is enabled), and transforming portions of the query string into phrase queries (see advancedSyntax).\n\ntimeoutCounts (boolean): Whether a timeout was hit when computing the facet counts. When true, the counts will be interpolated (i.e. approximate). See also exhaustiveFacetsCount.\n\ntimeoutHits (boolean): Whether a timeout was hit when retrieving the hits. When true, some results may be missing.",
                    "key": "getRankingInfo",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFY": {
                    "doc": "Enable the Click Analytics feature.\n\nThe effect of setting clickAnalytics to true is to add a queryID to the search response. As explained here, this queryID can subsequently be used in click and conversion analytics.\n\nUsage notes:#\nThis parameter does not, on its own, add any new analytics data; it only ensures that a queryID is returned. With that queryID, it will be up to you then to choose the best events to send as clicks and conversions. See Analytics Implementation Overview.\n\nWhat you can do with Analytics depends on your plan.",
                    "key": "clickAnalytics",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFZ": {
                    "doc": "Whether the current query will be taken into account in the Analytics.\n\nUsage notes:#\nAlgolia captures analytics on every search. This is the default setting. Therefore, this setting‚Äôs primary use is to turn analytics off for a given query.",
                    "key": "analytics",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFa": {
                    "doc": "List of tags to apply to the query for analytics purposes.\n\nYou can use tags in analytics to filter searches. For example, you can send two different tags - mobile and website - to see how mobile users search in comparison to website users.\n\nThere are a couple of limitations to keep in mind when sending analytics tags:\n\nTags can be up to 100 characters long. Longer tags are ignored.\nTags starting with alg# are reserved for internal usage and are ignored.\nA query has a maximum of 10 unique tags. Extra tags are ignored.\nA maximum of 3,500 unique tags combinations is processed per 5-minute window. All extra tags are ignored. A tags combination is the list of tags found in a query. For example, sending 3 queries, each respectively tagged with platform:ios, lang:en, and platform:ios,lang:en, counts as 3 combinations.",
                    "key": "analyticsTags",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFb": {
                    "doc": "Whether to take into account an index‚Äôs synonyms for a particular search.\n\nThis setting overrides the default query behavior, which is to use all defined synonyms on every search. By setting this to false, you are disabling synonyms for the given query. True is the engine default.",
                    "key": "synonyms",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFc": {
                    "doc": "Whether to highlight and snippet the original word that matches the synonym or the synonym itself.\n\nFor example, let‚Äôs say you set up home as a synonym for house, and the user types home. Synonym logic will match any record that contains ‚Äòhouse‚Äô with the synonym ‚Äòhome‚Äô. This setting will replace the word ‚Äòhouse‚Äô with ‚Äòhome‚Äô in the response. The effect of this is that all highlighting and snippeting will be on the synonym ‚Äòhome‚Äô. Without this setting, the original word ‚Äòhouse‚Äô would have been returned and highlighted and snippeted.\n\nUsage notes:#\nWhen true, highlighting and snippeting will use words from the query rather than the original words from the objects.\n\nWhen false, highlighting and snippeting will always display the original words from the objects.\n\nMultiple words can be replaced by a one-word synonym, but not the other way round. For example, if ‚ÄúNYC‚Äù and ‚ÄúNew York City‚Äù are synonyms, searching for ‚ÄúNYC‚Äù will replace ‚ÄúNew York City‚Äù with ‚ÄúNYC‚Äù in highlights and snippets, but searching for ‚ÄúNew York City‚Äù will not replace ‚ÄúNYC‚Äù with ‚ÄúNew York City‚Äù in highlights and snippets.",
                    "key": "replaceSynonymsInHighlight",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFd": {
                    "doc": "Precision of the proximity ranking criterion.\n\nUsage notes:#\nThe minimum (and best) proximity value between two matching words is 1. This is the engine default.\n\nSetting it to 2 (respectively N) would allow 1 (respectively N-1) additional word(s) to be found between two matching words without degrading the proximity ranking value.\n\nFor example, consider the query ‚Äújavascript framework‚Äù. If you set minProximity to 2, two records containing respectively ‚ÄúJavaScript framework‚Äù and ‚ÄúJavaScript charting framework‚Äù will get the same proximity score, even if the latter contains an additional word between the two matching words.\n\nThe maximum value for minProximity is 7. Any higher value will disable the proximity criterion in the ranking formula.",
                    "key": "minProximity",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFe": {
                    "doc": "Choose which fields the response will contain. Applies to search and browse queries.\n\nThis parameter is mainly intended to limit the response size. For example, in complex queries, echoing of request parameters in the response‚Äôs params field can be undesirable.\n\nUsage notes:#\nBy default, all fields are returned. If this parameter is specified, only the fields explicitly listed will be returned, unless * is used, in which case all fields are returned. Specifying an empty list or unknown field names is an error.\n\nList of fields that can be filtered out:\n\naroundLatLng\nautomaticRadius\nexhaustiveFacetsCount\nfacets\nfacets_stats\nhits\nhitsPerPage\nindex\nlength\nnbHits\nnbPages\noffset\npage\nparams\nprocessingTimeMS\nquery\nqueryAfterRemoval\nuserData\nList of fields that cannot be filtered out:\n\nmessage\nwarning\ncursor\nserverUsed\nindexUsed\nabTestVariantID\ntimeoutCounts (deprecated, please use exhaustiveFacetsCount instead)\ntimeoutHits (deprecated, please use exhaustiveFacetsCount instead)\nparsedQuery\nall fields triggered by getRankingInfo",
                    "key": "responseFields",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFf": {
                    "doc": "Maximum number of facet hits to return during a search for facet values.\n\nIf you want to change the number of retrieved facet values for a regular search, see maxValuesPerFacet.\n\nUsage notes:#\nDoes not apply to regular search queries.\n\nFor performance reasons, the maximum allowed number of returned values is 100. Any value outside the range [1, 100] will be rejected.",
                    "key": "maxFacetHits",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFg": {
                    "doc": "Whether to include or exclude a query from the processing-time percentile computation.\n\nUsage notes:#\nWhen true, the API saves the processing time of the search query and includes it when computing the 90% and 99% percentiles, available in your Algolia dashboard.\n\nWhen false, the search query is excluded from the percentile computation.",
                    "key": "percentileComputation",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFh": {
                    "doc": "When attribute is ranked above proximity in your ranking formula, proximity is used to select which searchable attribute is matched in the attribute ranking stage.\n\nUsage notes:#\nThis parameter can only impact relevance when attribute comes before proximity in the ranking formula. By default, this isn‚Äôt the case. The rationale for ranking proximity above attribute is detailed in the ranking criteria section. Generally, for objects with long text sections and a clear searchable attribute order (like documentation), it can be beneficial to rank by attribute before proximity.\n\nattributeCriteriaComputedByMinProximity works in the following way: By default, searches that match multiple searchable attributes are ranked by their best matching attribute (depending on searchable attributes order). However, if you set this parameter to true, the matched attribute is selected based on minimum proximity. In other words, if a search query matches on an object in multiple, different searchable attributes, the one with the smallest proximity is selected.\n\nFor example, consider an index of books, where you have set your searchable attributes to title, author, and description (in that order), and where you‚Äôve changed the ranking formula so that attribute comes before proximity. If the search for a book matches on both its title, with a proximity of 6, and description, with a proximity of 1, then title remains the best matching attribute even though description has a better proximity score. Setting attributeCriteriaComputedByMinProximity to true computes the best matching attribute based on minimum proximity; in our case, description is used instead of title.",
                    "key": "attributeCriteriaComputedByMinProximity",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AFi": {
                    "doc": "Whether this search should participate in running AB tests.\n\nUsage notes:#\nBy default, a search participates in currently active AB tests. You can prevent this by setting the enableABTest parameter to false. You may want to do this for searches performed in closed environments (like administration panels), or for searches that must target specific index variants during testing or development.",
                    "key": "enableABTest",
                    "optional": true,
                    "private": true,
                    "value": ""
                },
                "AGI": {
                    "doc": "Cursor indicating the location to resume browsing from. Must match the value returned by the previous call.",
                    "key": "cursor",
                    "optional": true,
                    "private": true,
                    "value": ""
                }
            },
            "publish_as": "data",
            "rank": 1,
            "ret_value": "api.1579418404674x846189550255734800.plugin_api.AGH",
            "types": "{\"plugin_api.AGH\":{\"caption\":\"üîçBrowseIndex\",\"fields\":{\"_p_hits\":{\"ret_value\":\"list.api.1579418404674x846189550255734800.plugin_api.AGH.hits\",\"caption\":\"hits\",\"path\":[\"hits\"]},\"_p_nbHits\":{\"ret_value\":\"number\",\"caption\":\"nbHits\",\"path\":[\"nbHits\"]},\"_p_page\":{\"ret_value\":\"number\",\"caption\":\"page\",\"path\":[\"page\"]},\"_p_nbPages\":{\"ret_value\":\"number\",\"caption\":\"nbPages\",\"path\":[\"nbPages\"]},\"_p_hitsPerPage\":{\"ret_value\":\"number\",\"caption\":\"hitsPerPage\",\"path\":[\"hitsPerPage\"]},\"_p_processingTimeMS\":{\"ret_value\":\"number\",\"caption\":\"processingTimeMS\",\"path\":[\"processingTimeMS\"]},\"_p_query\":{\"ret_value\":\"text\",\"caption\":\"query\",\"path\":[\"query\"]},\"_p_params\":{\"ret_value\":\"text\",\"caption\":\"params\",\"path\":[\"params\"]}}},\"plugin_api.AGH.hits\":{\"caption\":\"üîçBrowseIndex hit\",\"fields\":{\"_p_name\":{\"ret_value\":\"_ignore\"},\"_p_company\":{\"ret_value\":\"_ignore\"},\"_p_email\":{\"ret_value\":\"_ignore\"},\"_p_objectID\":{\"ret_value\":\"text\",\"caption\":\"objectID\",\"path\":[\"objectID\"]},\"_p_user_signed_up\":{\"ret_value\":\"_ignore\"},\"_p_üìùDescription\":{\"ret_value\":\"_ignore\"},\"_p_üòáSelfieUrl\":{\"ret_value\":\"_ignore\"},\"_p_üî°PageName\":{\"ret_value\":\"_ignore\"},\"_p_üî†Name\":{\"ret_value\":\"_ignore\"},\"_p_üèûPosts\":{\"ret_value\":\"_ignore\"},\"_p_üì®DisableMessages\":{\"ret_value\":\"_ignore\"},\"_p_üîìPrivate\":{\"ret_value\":\"_ignore\"},\"_p_üòéSelfiePose\":{\"ret_value\":\"_ignore\"},\"_p_üíÄDisabledAccount\":{\"ret_value\":\"_ignore\"},\"_p_üî†NameEdit\":{\"ret_value\":\"_ignore\"},\"_p_üìùDescriptionEdit\":{\"ret_value\":\"_ignore\"},\"_p__id\":{\"ret_value\":\"text\",\"caption\":\"_id\",\"path\":[\"_id\"]},\"_p___snapchatusername_text\":{\"ret_value\":\"_ignore\"},\"_p_Created Date\":{\"ret_value\":\"text\",\"caption\":\"Created Date\",\"path\":[\"Created Date\"]},\"_p_Modified Date\":{\"ret_value\":\"text\",\"caption\":\"Modified Date\",\"path\":[\"Modified Date\"]},\"_p_authentication.üòéBitmoji.id\":{\"ret_value\":\"_ignore\"},\"_p_authentication.üòéBitmoji.access_token\":{\"ret_value\":\"_ignore\"},\"_p_üë™Following\":{\"ret_value\":\"_ignore\"},\"_p___selfiestringnew_text\":{\"ret_value\":\"_ignore\"},\"_p_üî¢Score\":{\"ret_value\":\"_ignore\"},\"_p_üë™RequestedFollowers\":{\"ret_value\":\"_ignore\"},\"_p_üôàHideNewPostStarter\":{\"ret_value\":\"_ignore\"},\"_p_üé®BitmojiStyle\":{\"ret_value\":\"_ignore\"},\"_p_‚õ¥Onboard\":{\"ret_value\":\"_ignore\"},\"_p___webmentions__boolean\":{\"ret_value\":\"_ignore\"},\"_p___webmessage__boolean\":{\"ret_value\":\"_ignore\"},\"_p___webinvites__boolean\":{\"ret_value\":\"_ignore\"},\"_p___showactivityscore__boolean\":{\"ret_value\":\"_ignore\"},\"_p_üí¨AllowAllMessages\":{\"ret_value\":\"_ignore\"},\"_p___allowtagging__boolean\":{\"ret_value\":\"_ignore\"},\"_p_üî•HotjarSiteId\":{\"ret_value\":\"_ignore\"},\"_p___webfollower__boolean\":{\"ret_value\":\"_ignore\"},\"_p___webrepost__boolean\":{\"ret_value\":\"_ignore\"},\"_p___webunlockedselfie__boolean\":{\"ret_value\":\"_ignore\"},\"_p_üîßTooltips\":{\"ret_value\":\"_ignore\"},\"_p_‚úåÔ∏èHidePH\":{\"ret_value\":\"_ignore\"},\"_p_üì¶DropboxAccessToken\":{\"ret_value\":\"_ignore\"},\"_p_üì¶DropboxCode\":{\"ret_value\":\"_ignore\"},\"_p_üö´Blocked\":{\"ret_value\":\"_ignore\"},\"_p_üë™RequestedToFollow\":{\"ret_value\":\"_ignore\"},\"_p__type\":{\"ret_value\":\"text\",\"caption\":\"_type\",\"path\":[\"_type\"]}}}}",
            "url": "https://[üî†AppId]-dsn.algolia.net/1/indexes/[üî†IndexName]/browse",
            "url_params": {
                "ABG": {
                    "doc": "Identifies which application you are accessing.",
                    "key": "üî†AppId",
                    "private": true,
                    "value": ""
                },
                "ABv": {
                    "doc": "Identifies which index you are accessing.",
                    "key": "üî†IndexName",
                    "private": true,
                    "value": ""
                }
            }
        },
        "AGN": {
            "0": "A",
            "1": "G",
            "2": "M",
            "body": "",
            "doc_link": "https://www.algolia.com/doc/rest-api/search/#clear-objects",
            "initialized": true,
            "method": "post",
            "name": "‚ôªÔ∏èClearObjects",
            "publish_as": "action",
            "rank": 3,
            "ret_value": "api.1579418404674x846189550255734800.plugin_api.AGN",
            "types": "{\"plugin_api.AGN\":{\"caption\":\"‚ôªÔ∏èClearObject\",\"fields\":{\"_p_updatedAt\":{\"ret_value\":\"text\",\"caption\":\"updatedAt\",\"path\":[\"updatedAt\"]},\"_p_taskID\":{\"ret_value\":\"number\",\"caption\":\"taskID\",\"path\":[\"taskID\"]}}}}",
            "url": "https://[üî†AppId]-dsn.algolia.net/1/indexes/[üî†IndexName]/clear",
            "url_params": {
                "ABG": {
                    "doc": "Identifies which application you are accessing.",
                    "key": "üî†AppId",
                    "private": true,
                    "value": "P9GN1RHTEL"
                },
                "ABv": {
                    "doc": "Identifies which index you are accessing.",
                    "key": "üî†IndexName",
                    "private": true,
                    "value": "bubble"
                }
            }
        }
    },
    "human": "‚è±Algolia",
    "shared_headers": {
        "ACD": {
            "doc": "Identifies which application you are accessing.",
            "key": "X-Algolia-Application-Id",
            "private": true,
            "visibility": "secret"
        },
        "ACE": {
            "doc": "authenticates the endpoint (you can pass any API key created with the API).",
            "key": "X-Algolia-API-Key",
            "private": true,
            "visibility": "secret"
        }
    }
}